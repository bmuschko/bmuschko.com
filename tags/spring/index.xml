<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>spring on Benjamin Muschko&#39;s development blog</title>
    <link>https://bmuschko.com/tags/spring/</link>
    <description>Recent content in spring on Benjamin Muschko&#39;s development blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Nov 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://bmuschko.com/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Testing a Java project with TestContainers on JUnit 5</title>
      <link>https://bmuschko.com/blog/java-project-testcontainers/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/java-project-testcontainers/</guid>
      <description>TestContainers is a helpful tool for writing integration and functional tests with Docker containers as fixtures. Starting with version 1.10.0, the Java library of TestContainers supports writing and executing tests with JUnit 5, a feature long-awaited by the community. Time to explore the functionality by example!
 In this blog post, you will learn how to build an image for a Java application on-the-fly, start up a container as test fixture and stop it after the test has finished.</description>
    </item>
    
    <item>
      <title>Injecting credentials into a Docker container running a Spring Boot application</title>
      <link>https://bmuschko.com/blog/docker-secret-spring-boot/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/docker-secret-spring-boot/</guid>
      <description>The profile concept in Spring Boot makes is extremely easy to provide configuration specific to a runtime environment. A typical setup might include configuration for the local development environment, a testing environment, staging and production. All you need to do is to provide a properties files per environment on the classpath e.g. application-dev.properties and application-prod.properties. At runtime, you can tell Spring Boot which profile to pick via command line option or environment variable.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Dockerizing a Spring Boot application</title>
      <link>https://bmuschko.com/blog/dockerized-spring-boot-app/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/dockerized-spring-boot-app/</guid>
      <description>The use of Docker has become widespread among companies big and small for a variety scenarios. Executing Docker from the command line for simple tasks is easy and becomes routine as soon as you get a hang of it. Having to enter Docker commands for a whole workflow can become tedious. It seems obvious that you might want to integrate Docker into an automated process for convenience and reproducibility. Gradle can help with defining and executing such a process with the help of the Docker plugin.</description>
    </item>
    
    <item>
      <title>Build pipelines with Jenkins 2 by example</title>
      <link>https://bmuschko.com/blog/jenkins-build-pipeline/</link>
      <pubDate>Mon, 30 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/jenkins-build-pipeline/</guid>
      <description>Introduction Jenkins World 2017 came to a close in late September. Time to revisit the improvements that have been made to the support for build pipelines. I am no stranger to using Jenkins to model a Continuous Delivery pipeline. In the dark ages, you had to construct a pipeline with the help of different Jenkins plugins bit by bit. The approach was highly brittle, inconsistent and full of magical tips and tricks.</description>
    </item>
    
  </channel>
</rss>