<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker on Benjamin Muschko&#39;s development blog</title>
    <link>https://bmuschko.com/tags/docker/</link>
    <description>Recent content in docker on Benjamin Muschko&#39;s development blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Nov 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://bmuschko.com/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Testing a Java project with TestContainers on JUnit 5</title>
      <link>https://bmuschko.com/blog/java-project-testcontainers/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/java-project-testcontainers/</guid>
      <description>TestContainers is a helpful tool for writing integration and functional tests with Docker containers as fixtures. Starting with version 1.10.0, the Java library of TestContainers supports writing and executing tests with JUnit 5, a feature long-awaited by the community. Time to explore the functionality by example!
 In this blog post, you will learn how to build an image for a Java application on-the-fly, start up a container as test fixture and stop it after the test has finished.</description>
    </item>
    
    <item>
      <title>Injecting credentials into a Docker container running a Spring Boot application</title>
      <link>https://bmuschko.com/blog/docker-secret-spring-boot/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/docker-secret-spring-boot/</guid>
      <description>The profile concept in Spring Boot makes is extremely easy to provide configuration specific to a runtime environment. A typical setup might include configuration for the local development environment, a testing environment, staging and production. All you need to do is to provide a properties files per environment on the classpath e.g. application-dev.properties and application-prod.properties. At runtime, you can tell Spring Boot which profile to pick via command line option or environment variable.</description>
    </item>
    
    <item>
      <title>Containerization workflow for Java apps with Jib</title>
      <link>https://bmuschko.com/blog/containerization-with-jib/</link>
      <pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/containerization-with-jib/</guid>
      <description>Containerizing a Java application is the natural extension to building a plain, executable JAR file: &#34;write once, run everywhere&#34;. Creating an optimized image for an application is far from straightforward and requires in-depth knowledge of Docker concepts and best practices.
 A typical developer worflow involves the following steps. First, you start out by writing a Dockerfile with the goal of producing an image small in size while at the same time ensuring cacheability of layers as much as possible.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Getting started with Docker Compose</title>
      <link>https://bmuschko.com/blog/gradle-docker-compose/</link>
      <pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/gradle-docker-compose/</guid>
      <description>Docker Compose is a tool for defining and running entire application stacks in containers. Gradle plays well with Docker Compose and can automate the bootstrapping of those containers from the build process. In a previous post, I discussed how to use Gradle to start and stop a Docker container for integration testing. In this blog post, I want to continue the discussion by explaining how to manage multiple containers with Compose.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Writing a Node.js convention plugin</title>
      <link>https://bmuschko.com/blog/gradle-docker-convention-plugin/</link>
      <pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/gradle-docker-convention-plugin/</guid>
      <description>The Gradle Docker plugin provides turnkey solutions to common use cases. In the previous blog posts of the series &#34;Docker with Gradle&#34;, we looked at creating a Docker image for a Spring Boot application and how to use the image as fixture for integration testing. If you read the articles, you might have noticed that the plugin capabilities are flexible enough to model different situations. Nevertheless, this approach can easily become tedious if you want to use it across multiple, independent projects.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Integration testing using containers</title>
      <link>https://bmuschko.com/blog/docker-integration-testing/</link>
      <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/docker-integration-testing/</guid>
      <description>In the first blog post on &#34;Docker with Gradle&#34; you learned how to package a Spring Boot application as a Docker image. After verifying that the image works as expected you pushed the image to a registry. Being able to produce and push a new image of an application with every single commit lays the foundation for enabling supplemental automation workflows.
 Integration testing plays an important role in the software development lifecycle to ensure functional and non-functional requirements have been met.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Dockerizing a Spring Boot application</title>
      <link>https://bmuschko.com/blog/dockerized-spring-boot-app/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/dockerized-spring-boot-app/</guid>
      <description>The use of Docker has become widespread among companies big and small for a variety scenarios. Executing Docker from the command line for simple tasks is easy and becomes routine as soon as you get a hang of it. Having to enter Docker commands for a whole workflow can become tedious. It seems obvious that you might want to integrate Docker into an automated process for convenience and reproducibility. Gradle can help with defining and executing such a process with the help of the Docker plugin.</description>
    </item>
    
  </channel>
</rss>