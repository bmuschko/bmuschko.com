+++
title = "JUnit 5 vs. Spock feature showdown"
tags = [
    "junit5",
    "spock",
    "testing",
    "mock",
    "mockito"
]
date = "2017-12-17"
draft = true
highlight = true
+++

== Introduction

link:http://junit.org/junit4/[JUnit 4] has been the go-to test framework for JVM-based software projects for over a decade. You can find the use of JUnit across the board in organizations from big entprises to startups. Despite its popularity, the test framework's functionality and features barely moved with the times. Due to its deep penetration into the industry, evolutionary changes became harder and harder to implement without introducing inevidable breakages to the API. 

With the rise of other JVM languages like Groovy and Kotlin, new, feature-rich test frameworks emerged. The test framework link:http://spockframework.org/[Spock] became a welcome alternative to JUnit for many projects fearless to adopt Groovy as part of their polyglot software stack. With the link:http://junit.org/junit5/docs/current/user-guide/#release-notes-5.0.0[first GA release of JUnit 5] in September 2017, the JUnit team brought real innovation to the established space of testing JVM code. Not only is the release packed with new features comparable to the ones provided by Spock, JUnit 5 also serves as a platform for launching other test frameworks on the JVM.

In this blog post, I am going to compare typical usage patterns and features implemented as JUnit 5 and Spock-based tests. Spock follows the link:https://en.wikipedia.org/wiki/Behavior-driven_development[behavior-driven development (BDD)] methodology. This post is not going to discuss the fundamental differences between JUnit 5 and Spock in this regard. You can find all sample code in a link:https://github.com/bmuschko/junit5-vs-spock-feature-comparison[dedicated repository on Github]. The sample code is based on JUnit 5.0.2 and Spock 1.1.

== Code under test

For the purpose of demonstrating the testing capabilities of both test frameworks, we'll use two sets of classes and/or interfaces. The simplest class provides methods for executing arithmetic operations as shown in listing 1. Most test framework features can be demonstrates with the help of `ArithmeticOperation.java`.

_ArithmeticOperation.java_
[source,java]
----
public class ArithmeticOperation {
    public int add(int a, int b) {
        return a + b;
    }

    public int substract(int a, int b) {
        return a - b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }

    public double divide(int a, int b) {
        return a / b;
    }
}
----

_Listing 1. Class implementing artithmetic operations_

More advanced testing capabilities e.g. code that throws an exception require a slightly more complex setup. The following interface and class read the contents of a file for a given `Path` instance.

_FileReader.java_
[source,java]
----
public interface FileReader {
    String readContent(Path path) throws IOException;
}
----

_Listing 2. File reader interface_

The implementation of the interface throws an `IOException` if the provided `Path` does not exist.

_DefaultFileReader.java_
[source,java]
----
public class DefaultFileReader implements FileReader {
    @Override
    public String readContent(Path path) throws IOException {
        if (Files.notExists(path)) {
            throw new IOException("File does not exist");
        }

        return new String(Files.readAllBytes(path));
    }
}
----

_Listing 3. Default file reader implementation_

You will find that another class is referenced in some of the test cases described below: `FileManager`. `FileManager` is just a wrapper around `FileReader` to demonstrate mocking capabilities for each test framework. You can find the link:https://github.com/bmuschko/junit5-vs-spock-feature-comparison/blob/master/src/main/java/com/bmuschko/test/comparison/FileManager.java[code for the class] in the source code repository.

== Test execution

Let's start with the most simplistic use case: marking test methods or the whole class for execution with the test framework. 

=== JUnit 5

In JUnit 5 you use the annotation `@Test` to indicate that a method should be executed as a test. JUnit 5 takes a different approach than JUnit 4. The annotation is only applicable to a method but not the class. The annotated test method must not be `private` or `static`. Test methods do not return a value.

_SimpleTest.java_
[source,java]
----
import org.junit.jupiter.api.Test;

public class SimpleTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Test
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }

    @Test
    void canMultiply() {
        assertEquals(6, arithmeticOperation.multiply(2, 3));
    }

    @Test
    void canDivide() {
        assertEquals(3, arithmeticOperation.divide(6, 2));
    }
}
----

_Listing 4. Using annotation to indicate test execution_

=== Spock

Spock takes a different approach than JUnit 5. To indicate that all methods of a class should be treated as test methods, you'll need to extend from `spock.lang.Specification`. On the one hand, extending from a class requires less work on your end to turn all methods into test methods. On the other hand, it makes it harder to create a hierarchy of parent classes in case you want to formalize reusable fixtures through inheritance. In case you do not want all methods to execute as tests then you can always <<disabling-tests,disable them>>.

_SimpleTest.groovy_
[source,groovy]
----
class SimpleTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    def canSubstract() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }

    def canMultiply() {
        expect:
        arithmeticOperation.multiply(2, 3) == 6
    }

    def canDivide() {
        expect:
        arithmeticOperation.divide(6, 2) == 3
    }
}
----

_Listing 5. Extending from Specification_

== Fixture set up and tear down

Many tests require fixtures to be set up before any of the test methods can successfully run. A fixture lays out the expected environment, class composition or services that need to be available for the test to run properly. Fixtures can be costly to create e.g. if a service endpoint needs to be spawned up. After the test method finishes the fixture may need to be cleaned up. JUnit 5 and Spock provide ways to create fixtures before individual test methods or just once per test class. Equivalent hooks are available for clean up functionality.

=== JUnit 5

JUnit 5 supports fixture set up and tear down through annotations. The responsible method names for the operations can have an arbitrary name. The relevant annotation are `@BeforeEach`, `@BeforeAll`, `@AfterEach` and `@AfterAll`. You can find more information about link:http://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations[those annotations] in the user guide. Using annotations to indicate fixture set up and tear down fills quite natural.

The following test demonstrates the use of `@BeforeEach` and `@AfterEach` to create and delete a temporary file so that the code under test, `FileReader`, can read from it.

_FixtureSetupCleanup.java_
[source,java]
----
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;

public class FixtureSetupCleanup {
    private final FileReader fileReader = new DefaultFileReader();
    private Path testFile;

    @BeforeEach
    void setup() throws IOException {
        testFile = Files.createTempFile("junit5", ".tmp");
    }

    @AfterEach
    void cleanup() {
        testFile.toFile().delete();
    }

    @Test
    void canReadFile() throws IOException {
        String text = "hello";
        Files.write(testFile, text.getBytes());
        assertEquals(text, fileReader.readContent(testFile));
    }
}
----

_Listing 6. Using annotations for setting up and tearing down fixtures_

=== Spock

Spock does not provide annotations to indicate fixture set up and tear down. If a test class implements the methods `setup()`, `setupSpec()`, `cleanup()`, and `cleanupSpec()` then Spock will automatically use the method body to handle fixtures. You can find more information about those methods in the link:http://spockframework.org/spock/docs/1.1/spock_primer.html[documentation].

_FixtureSetupCleanup.groovy_
[source,groovy]
----
class FixtureSetupCleanup extends Specification {
    @Subject def fileReader = new DefaultFileReader()
    def testFile

    def setup() {
        testFile = Files.createTempFile("junit5", ".tmp")
    }

    def cleanup() {
        testFile.toFile().delete()
    }

    def "can read file"() {
        given:
        def text = "hello"
        testFile << text

        when:
        def content = fileReader.readContent(testFile)

        then:
        content == text
    }
}
----

_Listing 7. Fixture methods in Spock_

== Descriptive test names

Test cases should clearly indicate its intent. Using a method name to describe what has been tests proves to be a weak concept in practice. JUnit 5 and Spock support directly or indirectly provide ways to make test cases descriptive.

=== JUnit 5

In JUnit 4 you could only rely on the actual method name to identify the test case. JUnit 5 introduces the annotation `@DisplayName` that allows users to provide a description of the intent. Check out the link:http://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names[user guide] for more information on display names.

_DescriptiveTest.java_
[source,java]
----
import org.junit.jupiter.api.DisplayName;

public class DescriptiveTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    @DisplayName("can add two numbers")
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Test
    @DisplayName("can substract a number from another one")
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }

    @Test
    @DisplayName("can multiple two numbers")
    void canMultiply() {
        assertEquals(6, arithmeticOperation.multiply(2, 3));
    }

    @Test
    @DisplayName("can divide two numbers")
    void canDivide() {
        assertEquals(3, arithmeticOperation.divide(6, 2));
    }
}
----

_Listing 8. Providing a descriptive test name by annotation_

The executing environment takes the test description into account and uses it instead of the method name. The following screenshot shows the test execution in IntelliJ.

image:/img/blog/junit5-vs-spock-showdown/descriptive-names-junit5.png[]

_Figure 1. Descriptive test names in IntelliJ_

=== Spock

Spock does not introduce an annotation to support descriptive test names. Instead it simply uses Groovy to do the heavy lifting. In Groovy you can provide any String as method name.

_DescriptiveTest.groovy_
[source,groovy]
----
class DescriptiveTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def "can add two numbers"() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    def "can substract a number from another one"() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }

    def "can multiple two numbers"() {
        expect:
        arithmeticOperation.multiply(2, 3) == 6
    }

    def "can divide two numbers"() {
        expect:
        arithmeticOperation.divide(6, 2) == 3
    }
}
----

_Listing 9. Using a String to provide a readable test description_

The execution environment properly evaluates the provided String as method name at runtime. The following screenshot shows how IntelliJ renders the executed test cases.

image:/img/blog/junit5-vs-spock-showdown/descriptive-names-spock.png[]

_Figure 2. Descriptive test names in IntelliJ_

[[disabling-tests]]
== Disabling tests

Under certain conditions you might want to disable specific test methods. That's typically the case if the test is failing and you need to disable the test temporarily or if the test covers functionality that hasn't been implemented yet.

=== JUnit 5

JUnit 5 provides the annotation `@Disabled` to either disable all tests in a test class or individual test methods. A user can provide an optional reason to explain why the test was disabled. The following example demonstrates how to disable the test case `canAdd()`. More details can be found in the link:http://junit.org/junit5/docs/current/user-guide/#writing-tests-disabling[user guide].

_IgnoredTest.java_
[source,java]
----
import org.junit.jupiter.api.Disabled;

public class IgnoredTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    @Disabled("for demonstration purposes")
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}
----

_Listing 10. Disabling test methods by annotation_

=== Spock

Disabling a test in Spock following the same pattern as JUnit 5. It introduces the annotation `@Ignore` which can apply to a type or a method and allows for providing an optional reason.

_IgnoredTest.groovy_
[source,java]
----
import spock.lang.Ignore

class IgnoredTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Ignore("for demonstration purposes")
    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}
----

_Listing 11. Using the Ignore annotation to disable a method_


== Expecting thrown exceptions

Under certain conditions methods can throw an exception. Being a good citizen you'll want to test those cases as well to verify that the "sad path".

=== JUnit 5

The JUnit 5 API provides fine-grained control over testing thrown exceptions. Any portions of code can be wrapped with the method `assertThrows`. The test will fail in case the wrapped code block does not thrown the expected exception. The link:http://junit.org/junit5/docs/current/user-guide/#writing-tests-nested[user guide] provides an even more elaborate sample.

_ExpectedExceptionTest.java_
[source,java]
----
import static org.junit.jupiter.api.Assertions.assertThrows;

public class ExpectedExceptionTest {
    private final FileReader fileReader = new DefaultFileReader();

    @Test
    void cannotReadNonExistentFile() {
        assertThrows(IOException.class, () -> {
            fileReader.readContent(Paths.get("hello.text"));
        });
    }
}
----

_Listing 12. Asserting that a code block throws an expected exception_

=== Spock

In Spock-based tests a class or method can be annotated with `@FailsWith` to indicate that a declared exception should be thrown. If you want more fine-grained control over which portion of the code should throw the exception then you'll have to implement a `try`/`catch` block and assert the exception type.

_ExpectedExceptionTest.java_
[source,groovy]
----
import spock.lang.FailsWith

class ExpectedExceptionTest extends Specification {
    @Subject def fileReader = new DefaultFileReader()

    @FailsWith(IOException)
    def "cannot read non-existent file"() {
        expect:
        fileReader.readContent(Paths.get('hello.text'))
    }
}
----

_Listing 13. Declaring an expected exception by annotation_

== Repeating test execution

Sometimes you'll want to verify that the execution of logic leads to the same result if executed more than once. There are various examples that come in mind where repeating a test is useful:

- verifying that functionality is idempotent
- ensuring that a service endpoint can handle subsequent requests
- caching of data works as expected

=== JUnit 5

Test cases can be executed multiple times in a row by using the `@RepeatedTest` annotation. In addition to the value declaring the number of repetitions you can also build a custom test name with the help of built-in variables. Check the link:http://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[user guide] for more information.

_RepetitionTest.java_
[source,java]
----
import org.junit.jupiter.api.RepeatedTest;

public class RepetitionTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @RepeatedTest(10)
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @RepeatedTest(value = 5, name = "Iteration {currentRepetition} of {totalRepetitions}")
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }
}
----

_Listing 14. Repeating a test method by annotation_

=== Spock

Spock doesn't not support test repetition out-of-the-box. You will need to implement your own mechanism. The following example code uses a `where` statement to repeat the test execution multiple times.

_RepetitionTest.groovy_
[source,groovy]
----
class RepetitionTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Unroll
    def "can add"() {
        expect:
        arithmeticOperation.add(1, 2) == 3

        where:
        i << (1..10)
    }

    @Unroll
    def "Iteration #i of 5"() {
        expect:
        arithmeticOperation.substract(2, 1) == 1

        where:
        i << (1..5)
    }
}
----

_Listing 15. Repeating a test method by counter_


== Declaring timeouts

Code under test may take some time to finish execution. Operations can be very costly, calls across network boundaries can take a longer than expected due to latency, load tests should finish in an predefined amount of time. JUnit 5 and Spock provide adequate support for declaring a timeout. The test fails if it doesn't finish in the expected time frame.

=== JUnit 5

A timeout in JUnit 5 is represented as assertion method. The timeout expects a `Duration` instance and the code block that should return in the expected time frame. You can learn more about the timeout assertion in the link:http://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions[user guide].

_RepetitionTest.java_
[source,java]
----
import static java.time.Duration.ofSeconds;
import static org.junit.jupiter.api.Assertions.assertTimeout;

public class TimeoutTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertTimeout(ofSeconds(2), () -> {
            assertEquals(3, arithmeticOperation.add(1, 2));
        });
    }
}
----

_Listing 16. Fail a test if it doesn't finish in expected timeout threshold_

=== Spock

Spock takes the route of providing an annotation to declare a timeout. The annotation can be assigned to the whole test class or individual test methods. The assigned value declares a timeout in seconds by default. However, you can provide a different `TimeUnit` if needed.

_RepetitionTest.groovy_
[source,groovy]
----
import spock.lang.Timeout

class TimeoutTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Timeout(2)
    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}
----

_Listing 17. Convenient timeout definition by annotation_

== Conditional test execution

In a large test suite you don't necessarily want to execute all tests in all environment. For example you could have tests that should just run in a Windows environment but not on Linux. Or you might implement test that should only run with a specific JDK. Being able to control test execution proves to be extremely valuable if your test coverage looks more complex.

=== JUnit 5

JUnit 5 introduces the assertion method `assumeTrue`. If the expression evaluates to `true` then any code that follows will be executed. Should it validate to `false` then the test logic that follows is skipped. Internally, JUnit throws an exception that needs to be handled by the runtime environment.

_ConditionalExecutionTest.java_
[source,java]
----
import static org.junit.jupiter.api.Assumptions.assumeTrue;

public class ConditionalExecutionTest {
    private final static String SYS_PROP_KEY = "junit5.test.enabled";
    private final static String SYS_PROP_TRUE_VALUE = "true";
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void testOnlyOnSystemSystemPropertySet() {
        assumeTrue(SYS_PROP_TRUE_VALUE.equals(System.getProperty(SYS_PROP_KEY)));
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}
----

_Listing 18. Conditional test execution by expression_

IntelliJ properly handles conditional execution. The console will render the message `org.opentest4j.TestAbortedException: Assumption failed: assumption is not true`. The following screenshot shows the skipped method.

image:/img/blog/junit5-vs-spock-showdown/conditional-execution-junit5.png[]

_Figure 3. IntelliJ handles a TestAbortedException thrown by JUnit 5_

=== Spock

Conditional test execution represents one of the features where Spock really shines. In Spock you can define the condition with the help of a closure containing any expression you'd like to define. The closure is assigned to either the annotation `@Requires` or `@IgnoreIf`. Overall Spock's support for conditional test execution feels more flexible than JUnit's capabilities. The following example shows the use of the `@Requires` annotation.

_ConditionalExecutionTest.groovy_
[source,groovy]
----
import spock.lang.Requires

class ConditionalExecutionTest extends Specification {
    private final static String SYS_PROP_KEY = "spock.test.enabled"
    private final static String SYS_PROP_TRUE_VALUE = "true"
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Requires({ SYS_PROP_TRUE_VALUE == sys[SYS_PROP_KEY] })
    def "can add"() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}
----

_Listing 19. Expression-based test execution defined as annotation parameter_

The following screenshot shows the handling in IntelliJ.

image:/img/blog/junit5-vs-spock-showdown/conditional-execution-spock.png[]

_Figure 4. Conditional test execution by annotation in IntelliJ_

== Data-driven tests

I personally use it all the time.

=== JUnit 5

_DataDrivenTest.java_
[source,java]
----
public class DataDrivenTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @ParameterizedTest
    @ValueSource(ints = { 1, 2, 3, 4, 5 })
    void canAdd(int b) {
        assertTrue(arithmeticOperation.add(1, b) >= 2);
    }

    @ParameterizedTest(name = "can add {0} to {1} and receive {2}")
    @MethodSource("additionProvider")
    void canAddAndAssertExactResult(int a, int b, int result) {
        assertEquals(result, arithmeticOperation.add(a, b));
    }

    static Stream<Arguments> additionProvider() {
        return Stream.of(
            Arguments.of(1, 3, 4),
            Arguments.of(3, 4, 7),
            Arguments.of(10, 20, 30)
        );
    }
}
----

_Listing 20. Declaring a value source and provider to provide data to test_

=== Spock

_DataDrivenTest.groovy_
[source,groovy]
----
class DataDrivenTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def "can add"() {
        expect:
        arithmeticOperation.add(1, b) >= 2

        where:
        b << [1, 2, 3, 4, 5]
    }

    @Unroll
    def "can add #a to #b and receive #result"() {
        expect:
        arithmeticOperation.add(a, b) == result

        where:
        a  | b  | result
        1  | 3  | 4
        3  | 4  | 7
        10 | 20 | 30
    }
}
----

_Listing 21. Providing data to test execution by table_

== Mocking

=== JUnit 5

_MockTest.java_
[source,java]
----
public class MockTest {
    private Path testFile;

    @BeforeEach
    void setup() throws IOException {
        testFile = Files.createTempFile("junit5", ".tmp");
    }

    @AfterEach
    void cleanup() {
        testFile.toFile().delete();
    }

    @Test
    void canMockFileReadOperation() throws IOException {
        String text = "hello";
        FileReader fileReader = mock(FileReader.class);
        when(fileReader.readContent(testFile)).thenReturn(text);
        FileManager fileManager = new DefaultFileManager(fileReader);
        Files.write(testFile, text.getBytes());
        assertEquals(text, fileManager.readContent(testFile));
    }
}
----

_Listing 22. Using Mockito to inject mock instance_

=== Spock

_MockTest.groovy_
[source,groovy]
----
class MockTest extends Specification {
    def fileReader = Mock(FileReader)
    @Subject def fileManager = new DefaultFileManager(fileReader)
    def testFile

    void setup() {
        testFile = Files.createTempFile("junit5", ".tmp")
    }

    void cleanup() {
        testFile.toFile().delete()
    }

    def "can mock file read operation"() {
        given:
        def text = "hello"
        Files.write(testFile, text.getBytes())

        when:
        def content = fileManager.readContent(testFile)

        then:
        1 * fileReader.readContent(testFile) >> text
        content == text
    }
}
----

_Listing 23. Built-in mock capabilities_


== Filtering test execution

=== JUnit 5

_FilteredFastTest.java_
[source,java]
----
@RunWith(JUnitPlatform.class)
@SelectPackages("com.bmuschko.test.comparison.junit5.tagged")
@IncludeTags("fast")
public class FilteredFastTest {
}
----

_Listing 24. Test suite executing fast tests_

_TaggedTest.java_
[source,java]
----
public class TaggedTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Tag("slow")
    @Test
    void runsSlowly() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Tag("fast")
    @Test
    void runsFast() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }
}
----

_Listing 25. Tagged test methods_

=== Spock

_Fast.groovy_
[source,groovy]
----
@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
@interface Fast {
}
----

_Listing 26. Interface annotation indicating fast tests_

_Slow.groovy_
[source,groovy]
----
@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
@interface Slow {
}
----

_Listing 27. Interface annotation indicating slow tests_

_TaggedTest.groovy_
[source,groovy]
----
class TaggedTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Slow
    def "runs slowly"() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    @Fast
    def "runs fast"() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }
}
----

_Listing 28. Annotated test methods_

_SpockConfig.groovy_
[source,groovy]
----
import com.bmuschko.test.comparison.spock.tagged.Fast

runner {
    include Fast
}
----

_Listing 29. Spock runner configuration to filter annotated tests_

== Extending the test framework

=== JUnit 5

_BeforeAfterLoggingExtension.java_
[source,java]
----
public class BeforeAfterLoggingExtension implements BeforeTestExecutionCallback, AfterTestExecutionCallback {
    @Override
    public void beforeTestExecution(ExtensionContext context) {
        Method testMethod = context.getRequiredTestMethod();
        System.out.println(String.format("Starting test method %s.%s", testMethod.getDeclaringClass(), testMethod.getName()));
    }

    @Override
    public void afterTestExecution(ExtensionContext context) {
        Method testMethod = context.getRequiredTestMethod();
        System.out.println(String.format("Finishing test method %s.%s", testMethod.getDeclaringClass(), testMethod.getName()));
    }
}
----

_Listing 30. Test execution callback handler_

_LoggingTest.java_
[source,java]
----
@ExtendWith(BeforeAfterLoggingExtension.class)
public class LoggingTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}
----

_Listing 31. Using extension in test class_

=== Spock

_BeforeAfterEventListener.groovy_
[source,groovy]
----
class BeforeAfterEventListener extends AbstractRunListener {
    @Override
    void beforeFeature(FeatureInfo feature) {
        println "Starting test method ${feature.description.className}.${feature.description.methodName}"
    }

    @Override
    void afterFeature(FeatureInfo feature) {
        println "Finishing test method ${feature.description.className}.${feature.description.methodName}"
    }
}
----

_Listing 32. Event listener implementation in Spock_

_BeforeAfterLogging.groovy_
[source,groovy]
----
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@ExtensionAnnotation(BeforeAfterLoggingExtension.class)
@interface BeforeAfterLogging {
}
----

_Listing 33. Exposing an annotation evaluated by extension_

_BeforeAfterLoggingExtension.groovy_
[source,groovy]
----
class BeforeAfterLoggingExtension extends AbstractAnnotationDrivenExtension<BeforeAfterLogging> {
    @Override
    void visitSpecAnnotation(BeforeAfterLogging annotation, SpecInfo spec) {
        spec.addListener(new BeforeAfterEventListener())
    }
}
----

_Listing 34. Registering the listener by extension_

_LoggingTest.groovy_
[source,groovy]
----
@BeforeAfterLogging
class LoggingTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}
----

_Listing 35. Using the logging extension in a test class_

== Conclusion