+++
title = "JUnit 5 vs. Spock feature showdown"
tags = [
    "junit5",
    "spock",
    "testing",
    "mock",
    "mockito"
]
date = "2017-12-17"
draft = true
highlight = true
+++

== Introduction

link:http://junit.org/junit4/[JUnit 4] has been the go-to test framework for JVM-based software projects for over a decade. You can find the use of JUnit across the board in organizations from big entprises to startups. Despite its popularity, the test framework's functionality and features barely moved with the times. Due to its deep penetration into the industry, evolutionary changes became harder and harder to implement without introducing inevidable breakages to the API. 

With the rise of other JVM languages like Groovy and Kotlin, new, feature-rich test frameworks emerged. The test framework link:http://spockframework.org/[Spock] became a welcome alternative to JUnit for many projects fearless to adopt Groovy as part of their polyglot software stack. With the link:http://junit.org/junit5/docs/current/user-guide/#release-notes-5.0.0[first GA release of JUnit 5] in September 2017, the JUnit team brought real innovation to the established space of testing JVM code. Not only is the release packed with new features comparable to the ones provided by Spock, JUnit 5 also serves as a platform for launching other test frameworks on the JVM.

In this blog post, I am going to compare typical usage patterns and features implemented as JUnit 5 and Spock-based tests. Spock follows the link:https://en.wikipedia.org/wiki/Behavior-driven_development[behavior-driven development (BDD)] methodology. This post is not going to discuss the fundamental differences between JUnit 5 and Spock in this regard. You can find all sample code in a link:https://github.com/bmuschko/junit5-vs-spock-feature-comparison[dedicated repository on Github].

== Code under test

For the purpose of demonstrating the testing capabilities of both test frameworks, we'll use two sets of classes and/or interfaces. The simplest class provides methods for executing arithmetic operations as shown in listing 1. Most test framework features can be demonstrates with the help of `ArithmeticOperation.java`.

_ArithmeticOperation.java_
[source,java]
----
public class ArithmeticOperation {
    public int add(int a, int b) {
        return a + b;
    }

    public int substract(int a, int b) {
        return a - b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }

    public double divide(int a, int b) {
        return a / b;
    }
}
----

_Listing 1. Class implementing artithmetic operations_

More advanced testing capabilities e.g. code that throws an exception require a slightly more complex setup. The following interface and class read the contents of a file for a given `Path` instance.

_FileReader.java_
[source,java]
----
public interface FileReader {
    String readContent(Path path) throws IOException;
}
----

_Listing 2. File reader interface_

The implementation of the interface throws an `IOException` if the provided `Path` does not exist.

_DefaultFileReader.java_
[source,java]
----
public class DefaultFileReader implements FileReader {
    @Override
    public String readContent(Path path) throws IOException {
        if (Files.notExists(path)) {
            throw new IOException("File does not exist");
        }

        return new String(Files.readAllBytes(path));
    }
}
----

_Listing 3. Default file reader implementation_

You will find that another class is referenced in some of the test cases described below: `FileManager`. `FileManager` is just a wrapper around `FileReader` to demonstrate mocking capabilities for each test framework. You can find the link:https://github.com/bmuschko/junit5-vs-spock-feature-comparison/blob/master/src/main/java/com/bmuschko/test/comparison/FileManager.java[code for the class] in the source code repository.

== Test execution

Let's start with the most simplistic use case: marking test methods or the whole class for execution with the test framework. 

=== JUnit 5

In JUnit 5 you use the annotation `org.junit.jupiter.api.Test` to indicate that a method should be executed as a test. JUnit 5 takes a different approach than JUnit 4. The annotation is only applicable to a method but not the class. The annotated test method must not be `private` or `static`. Test methods do not return a value.

_SimpleTest.java_
[source,java]
----
public class SimpleTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Test
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }

    @Test
    void canMultiply() {
        assertEquals(6, arithmeticOperation.multiply(2, 3));
    }

    @Test
    void canDivide() {
        assertEquals(3, arithmeticOperation.divide(6, 2));
    }
}
----

_Listing 4. Using annotation to indicate test execution_

=== Spock

Spock takes a different approach than JUnit 5. To indicate that all methods of a class should be treated as test methods, you'll need to extend from `spock.lang.Specification`. On the one hand, extending from a class requires less work on your end to turn all methods into test methods. On the other hand, it makes it harder to create a hierarchy of parent classes in case you want to formalize reusable fixtures through inheritance. In case you do not want all methods to execute as tests then you can always <<disabling-tests,disable them>>.

_SimpleTest.groovy_
[source,groovy]
----
class SimpleTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    def canSubstract() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }

    def canMultiply() {
        expect:
        arithmeticOperation.multiply(2, 3) == 6
    }

    def canDivide() {
        expect:
        arithmeticOperation.divide(6, 2) == 3
    }
}
----

_Listing 5. Extending from Specification_


== Fixture set up and tear down

=== JUnit 5

_FixtureSetupCleanup.java_
[source,java]
----
public class FixtureSetupCleanup {
    private final FileReader fileReader = new DefaultFileReader();
    private Path testFile;

    @BeforeEach
    void setup() throws IOException {
        testFile = Files.createTempFile("junit5", ".tmp");
    }

    @AfterEach
    void cleanup() {
        testFile.toFile().delete();
    }

    @Test
    void canReadFile() throws IOException {
        String text = "hello";
        Files.write(testFile, text.getBytes());
        assertEquals(text, fileReader.readContent(testFile));
    }
}
----

_Listing 6. Using annotations for setting up and tearing down fixtures_

=== Spock

_FixtureSetupCleanup.groovy_
[source,groovy]
----
class FixtureSetupCleanup extends Specification {
    @Subject def fileReader = new DefaultFileReader()
    def testFile

    def setup() {
        testFile = Files.createTempFile("junit5", ".tmp")
    }

    def cleanup() {
        testFile.toFile().delete()
    }

    def "can read file"() {
        given:
        def text = "hello"
        testFile << text

        when:
        def content = fileReader.readContent(testFile)

        then:
        content == text
    }
}
----

_Listing 7. Fixture methods in Spock_


== Descriptive test names

=== JUnit 5

_DescriptiveTest.java_
[source,java]
----
public class DescriptiveTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    @DisplayName("can add two numbers")
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Test
    @DisplayName("can substract a number from another one")
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }

    @Test
    @DisplayName("can multiple two numbers")
    void canMultiply() {
        assertEquals(6, arithmeticOperation.multiply(2, 3));
    }

    @Test
    @DisplayName("can divide two numbers")
    void canDivide() {
        assertEquals(3, arithmeticOperation.divide(6, 2));
    }
}
----

_Listing 8. Providing a descriptive test name by annotation_

=== Spock

_DescriptiveTest.groovy_
[source,groovy]
----
class DescriptiveTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def "can add two numbers"() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    def "can substract a number from another one"() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }

    def "can multiple two numbers"() {
        expect:
        arithmeticOperation.multiply(2, 3) == 6
    }

    def "can divide two numbers"() {
        expect:
        arithmeticOperation.divide(6, 2) == 3
    }
}
----

_Listing 9. Using a String to provide a readable test description_

[[disabling-tests]]
== Disabling tests

=== JUnit 5

_IgnoredTest.java_
[source,java]
----
public class IgnoredTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    @Disabled("for demonstration purposes")
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}
----

_Listing 10. Disabling test methods by annotation_

=== Spock

_IgnoredTest.groovy_
[source,java]
----
class IgnoredTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Ignore("for demonstration purposes")
    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}
----

_Listing 11. Using the Ignore annotation to disable a method_


== Expecting thrown exceptions

=== JUnit 5

_ExpectedExceptionTest.java_
[source,java]
----
public class ExpectedExceptionTest {
    private final FileReader fileReader = new DefaultFileReader();

    @Test
    void cannotReadNonExistentFile() {
        assertThrows(IOException.class, () -> {
            fileReader.readContent(Paths.get("hello.text"));
        });
    }
}
----

_Listing 12. Asserting that a code block throws an expected exception_

=== Spock

_ExpectedExceptionTest.java_
[source,groovy]
----
class ExpectedExceptionTest extends Specification {
    @Subject def fileReader = new DefaultFileReader()

    @FailsWith(IOException)
    def "cannot read non-existent file"() {
        expect:
        fileReader.readContent(Paths.get('hello.text'))
    }
}
----

_Listing 13. Declaring an expected exception by annotation_


== Repeating test execution

=== JUnit 5

_RepetitionTest.java_
[source,java]
----
public class RepetitionTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @RepeatedTest(10)
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @RepeatedTest(value = 5, name = "Iteration {currentRepetition} of {totalRepetitions}")
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }
}
----

_Listing 14. Repeating a test method by annotation_

=== Spock

_RepetitionTest.groovy_
[source,groovy]
----
class RepetitionTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Unroll
    def "can add"() {
        expect:
        arithmeticOperation.add(1, 2) == 3

        where:
        i << (1..10)
    }

    @Unroll
    def "Iteration #i of 5"() {
        expect:
        arithmeticOperation.substract(2, 1) == 1

        where:
        i << (1..5)
    }
}
----

_Listing 15. Repeating a test method by counter_


== Declaring timeouts

=== JUnit 5

_RepetitionTest.java_
[source,java]
----
public class TimeoutTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertTimeout(ofSeconds(2), () -> {
            assertEquals(3, arithmeticOperation.add(1, 2));
        });
    }
}
----

_Listing 16. Fail a test if it doesn't finish in expected timeout threshold_

=== Spock

_RepetitionTest.groovy_
[source,groovy]
----
class TimeoutTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Timeout(2)
    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}
----

_Listing 17. Convenient timeout definition by annotation_


== Conditional test execution

=== JUnit 5

_ConditionalExecutionTest.java_
[source,java]
----
public class ConditionalExecutionTest {
    private final static String SYS_PROP_KEY = "junit5.test.enabled";
    private final static String SYS_PROP_TRUE_VALUE = "true";
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void testOnlyOnSystemSystemPropertySet() {
        assumeTrue(SYS_PROP_TRUE_VALUE.equals(System.getProperty(SYS_PROP_KEY)));
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}
----

_Listing 18. Conditional test execution by expression_

=== Spock

_ConditionalExecutionTest.groovy_
[source,groovy]
----
class ConditionalExecutionTest extends Specification {
    private final static String SYS_PROP_KEY = "spock.test.enabled"
    private final static String SYS_PROP_TRUE_VALUE = "true"
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Requires({ SYS_PROP_TRUE_VALUE == sys[SYS_PROP_KEY] })
    def "can add"() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}
----

_Listing 19. Expression-based test execution defined as annotation parameter_

== Data-driven tests

=== JUnit 5

_DataDrivenTest.java_
[source,java]
----
public class DataDrivenTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @ParameterizedTest
    @ValueSource(ints = { 1, 2, 3, 4, 5 })
    void canAdd(int b) {
        assertTrue(arithmeticOperation.add(1, b) >= 2);
    }

    @ParameterizedTest(name = "can add {0} to {1} and receive {2}")
    @MethodSource("additionProvider")
    void canAddAndAssertExactResult(int a, int b, int result) {
        assertEquals(result, arithmeticOperation.add(a, b));
    }

    static Stream<Arguments> additionProvider() {
        return Stream.of(
            Arguments.of(1, 3, 4),
            Arguments.of(3, 4, 7),
            Arguments.of(10, 20, 30)
        );
    }
}
----

_Listing 20. Declaring a value source and provider to provide data to test_

=== Spock

_DataDrivenTest.groovy_
[source,groovy]
----
class DataDrivenTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def "can add"() {
        expect:
        arithmeticOperation.add(1, b) >= 2

        where:
        b << [1, 2, 3, 4, 5]
    }

    @Unroll
    def "can add #a to #b and receive #result"() {
        expect:
        arithmeticOperation.add(a, b) == result

        where:
        a  | b  | result
        1  | 3  | 4
        3  | 4  | 7
        10 | 20 | 30
    }
}
----

_Listing 21. Providing data to test execution by table_

== Mocking

=== JUnit 5

_MockTest.java_
[source,java]
----
public class MockTest {
    private Path testFile;

    @BeforeEach
    void setup() throws IOException {
        testFile = Files.createTempFile("junit5", ".tmp");
    }

    @AfterEach
    void cleanup() {
        testFile.toFile().delete();
    }

    @Test
    void canMockFileReadOperation() throws IOException {
        String text = "hello";
        FileReader fileReader = mock(FileReader.class);
        when(fileReader.readContent(testFile)).thenReturn(text);
        FileManager fileManager = new DefaultFileManager(fileReader);
        Files.write(testFile, text.getBytes());
        assertEquals(text, fileManager.readContent(testFile));
    }
}
----

_Listing 22. Using Mockito to inject mock instance_

=== Spock

_MockTest.groovy_
[source,groovy]
----
class MockTest extends Specification {
    def fileReader = Mock(FileReader)
    @Subject def fileManager = new DefaultFileManager(fileReader)
    def testFile

    void setup() {
        testFile = Files.createTempFile("junit5", ".tmp")
    }

    void cleanup() {
        testFile.toFile().delete()
    }

    def "can mock file read operation"() {
        given:
        def text = "hello"
        Files.write(testFile, text.getBytes())

        when:
        def content = fileManager.readContent(testFile)

        then:
        1 * fileReader.readContent(testFile) >> text
        content == text
    }
}
----

_Listing 23. Built-in mock capabilities_


== Filtering test execution

=== JUnit 5

_FilteredFastTest.java_
[source,java]
----
@RunWith(JUnitPlatform.class)
@SelectPackages("com.bmuschko.test.comparison.junit5.tagged")
@IncludeTags("fast")
public class FilteredFastTest {
}
----

_Listing 24. Test suite executing fast tests_

_TaggedTest.java_
[source,java]
----
public class TaggedTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Tag("slow")
    @Test
    void runsSlowly() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Tag("fast")
    @Test
    void runsFast() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }
}
----

_Listing 25. Tagged test methods_

=== Spock

_Fast.groovy_
[source,groovy]
----
@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
@interface Fast {
}
----

_Listing 26. Interface annotation indicating fast tests_

_Slow.groovy_
[source,groovy]
----
@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
@interface Slow {
}
----

_Listing 27. Interface annotation indicating slow tests_

_TaggedTest.groovy_
[source,groovy]
----
class TaggedTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Slow
    def "runs slowly"() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    @Fast
    def "runs fast"() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }
}
----

_Listing 28. Annotated test methods_

_SpockConfig.groovy_
[source,groovy]
----
import com.bmuschko.test.comparison.spock.tagged.Fast

runner {
    include Fast
}
----

_Listing 29. Spock runner configuration to filter annotated tests_

== Extending the test framework

=== JUnit 5

_BeforeAfterLoggingExtension.java_
[source,java]
----
public class BeforeAfterLoggingExtension implements BeforeTestExecutionCallback, AfterTestExecutionCallback {
    @Override
    public void beforeTestExecution(ExtensionContext context) {
        Method testMethod = context.getRequiredTestMethod();
        System.out.println(String.format("Starting test method %s.%s", testMethod.getDeclaringClass(), testMethod.getName()));
    }

    @Override
    public void afterTestExecution(ExtensionContext context) {
        Method testMethod = context.getRequiredTestMethod();
        System.out.println(String.format("Finishing test method %s.%s", testMethod.getDeclaringClass(), testMethod.getName()));
    }
}
----

_Listing 30. Test execution callback handler_

_LoggingTest.java_
[source,java]
----
@ExtendWith(BeforeAfterLoggingExtension.class)
public class LoggingTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}
----

_Listing 31. Using extension in test class_

=== Spock

_BeforeAfterEventListener.groovy_
[source,groovy]
----
class BeforeAfterEventListener extends AbstractRunListener {
    @Override
    void beforeFeature(FeatureInfo feature) {
        println "Starting test method ${feature.description.className}.${feature.description.methodName}"
    }

    @Override
    void afterFeature(FeatureInfo feature) {
        println "Finishing test method ${feature.description.className}.${feature.description.methodName}"
    }
}
----

_Listing 32. Event listener implementation in Spock_

_BeforeAfterLogging.groovy_
[source,groovy]
----
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@ExtensionAnnotation(BeforeAfterLoggingExtension.class)
@interface BeforeAfterLogging {
}
----

_Listing 33. Exposing an annotation evaluated by extension_

_BeforeAfterLoggingExtension.groovy_
[source,groovy]
----
class BeforeAfterLoggingExtension extends AbstractAnnotationDrivenExtension<BeforeAfterLogging> {
    @Override
    void visitSpecAnnotation(BeforeAfterLogging annotation, SpecInfo spec) {
        spec.addListener(new BeforeAfterEventListener())
    }
}
----

_Listing 34. Registering the listener by extension_

_LoggingTest.groovy_
[source,groovy]
----
@BeforeAfterLogging
class LoggingTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}
----

_Listing 35. Using the logging extension in a test class_

== Conclusion