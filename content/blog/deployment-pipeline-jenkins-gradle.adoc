+++
title = "Crafting a real-world build pipeline with Jenkins by example"
tags = [
    "build",
    "continuous",
    "delivery",
    "deployment",
    "jenkins",
    "gradle",
    "spring",
    "heroku",
    "web-app"
]
date = "2017-10-01"
draft = true
highlight = true
+++

== Introduction

link:https://www.cloudbees.com/jenkinsworld/home[Jenkins World 2017] just came to a close two weeks ago. Time to revisit the improvements that have been made to the support for build pipelines. I am no stranger to using Jenkins to model a Continuous Delivery pipeline. In the dark ages, you had to construct a pipeline with the help of different Jenkins plugins bit by bit. The approach was highly brittle, inconsistent and full of magical tips and tricks. You can find a discussion of the approach in my book link:https://www.manning.com/books/gradle-in-action[Gradle in Action].

In this blog post, I am going to discuss how to construct and operate a link:https://jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline[declarative pipeline with Jenkins]. The vehicle for the pipeline is a Java-based web application using Spring Boot built with Gradle. To emulate a real-world scenario, every change made to the project is travels through the full pipeline and is deployed to Heroku on demand. You can find the link:https://github.com/bmuschko/todo-spring-boot[full source code on GitHub].

== The sample application

The functionality of the sample application is straight-forward. It allows you to record to-do items that can completed by checking them off the list. A database stores the to-do items and their states. Figure 1 shows a screenshot of the deployed application. You can try out the application for yourself deployed on Heroku.

image:/img/blog/deployment-pipeline-jenkins-gradle/todo-app-screenshot.png[]

_Figure 1. A web-based application for managing to-do items_

On the technical side, the web application was built with Java and Spring Boot. Unit tests have been implemented in the directory `src/test/java`. Under `src/integrationTest/java` you can find integration tests for the controller and data access layer.

== Modeling the build pipeline

== Unit and integration testing

== Static code analysis with SonarCloud

_code-analysis.gradle_
[source,groovy]
----
buildscript {
    repositories {
        maven {
            url 'https://plugins.gradle.org/m2/'
        }
    }
    dependencies {
        classpath 'org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.5'
    }
}

apply plugin: org.sonarqube.gradle.SonarQubePlugin
----

_code-analysis.gradle_
[source,groovy]
----
sonarqube {
    properties {
        property 'sonar.host.url', 'https://sonarcloud.io'
        property 'sonar.organization', 'bmuschko-github'
        property 'sonar.login', System.getenv('SONAR_LOGIN')
        properties['sonar.tests'] += sourceSets.integrationTest.java.srcDirs
    }
}
----

== The target runtime platform

_deploy.gradle_
[source,groovy]
----
buildscript {
    repositories {
        maven {
            url 'https://plugins.gradle.org/m2/'
        }
    }
    dependencies {
        classpath 'gradle.plugin.com.heroku.sdk:heroku-gradle:0.3.0'
    }
}

apply plugin: com.heroku.sdk.gradle.HerokuPlugin
----

_build.gradle_
[source,groovy]
----
heroku {
    appName = 'todo-spring-boot'
    includes = ["$buildDir.name/libs/$war.archiveName"]
    includeBuildDir = false

    processTypes(
        web: "java \$JAVA_OPTS -jar $buildDir.name/libs/$war.archiveName --server.port=\$PORT".toString()
    )
}

deployHeroku {
    dependsOn assemble

    doFirst {
        if (!System.getenv('HEROKU_API_KEY')) {
            throw new GradleException('Deployment to Heroku requires setting the environment variable HEROKU_API_KEY')
        }
    }
}
----

== Modeling the pipeline

== Setting up Jenkins

== Declarative pipeline

image:/img/blog/deployment-pipeline-jenkins-gradle/blue-ocean-input-wait.png[]

image:/img/blog/deployment-pipeline-jenkins-gradle/blue-ocean-input-abort.png[]

image:/img/blog/deployment-pipeline-jenkins-gradle/blue-ocean-all-green.png[]

_Jenkinsfile_
[source,groovy]
----
pipeline {
    agent any

    triggers {
        pollSCM('*/5 * * * *')
    }

    stages {
        stage('Compile') {
            steps {
                gradlew('clean', 'classes')
            }
        }
        stage('Unit Tests') {
            steps {
                gradlew('test')
            }
            post {
                always {
                    junit '**/build/test-results/test/TEST-*.xml'
                }
            }
        }
        stage('Long-running Verification') {
            environment {
                SONAR_LOGIN = credentials('SONARCLOUD_TOKEN')
            }
            parallel {
                stage('Integration Tests') {
                    steps {
                        gradlew('integrationTest')
                    }
                    post {
                        always {
                            junit '**/build/test-results/integrationTest/TEST-*.xml'
                        }
                    }
                }
                stage('Code Analysis') {
                    steps {
                        gradlew('sonarqube')
                    }
                }
            }
        }
        stage('Assemble') {
            steps {
                gradlew('assemble')
                stash includes: '**/build/libs/*.war', name: 'app'
            }
        }
        stage('Promotion') {
            steps {
                timeout(time: 1, unit:'DAYS') {
                    input 'Deploy to Production?'
                }
            }
        }
        stage('Deploy to Production') {
            environment {
                HEROKU_API_KEY = credentials('HEROKU_API_KEY')
            }
            steps {
                unstash 'app'
                gradlew('deployHeroku')
            }
        }
    }
    post {
        failure {
            mail to: 'benjamin.muschko@gmail.com', subject: 'Build failed', body: 'Please fix!'
        }
    }
}

def gradlew(String... args) {
    sh "./gradlew ${args.join(' ')} -s"
}
----