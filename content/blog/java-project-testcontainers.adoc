+++
title = "Integration testing a Java project with TestContainers on JUnit 5"
tags = [
    "java",
    "spring",
    "boot",
    "docker",
    "container",
    "testing",
    "testcontainers"
]
date = "2018-11-12"
draft = true
highlight = true
+++

https://www.testcontainers.org/[TestContainers] is a helpful tool for writing integration and functional tests with Docker containers as fixtures. With https://github.com/testcontainers/testcontainers-java/releases/tag/1.10.0[version 1.10.0], the Java library of TestContainers supports writing and executing tests with JUnit 5, a feature the community has been waiting for a long time. Time to explore the functionality!

In this blog post, you will learn how to build an image for a Java application on-the-fly, start up a container as test fixture and stop it after the test has finished. You will also understand how to set up a Gradle build and IntelliJ to run those tests. 

== Configuring the dependencies

Before you can get started writing tests with JUnit 5 and TestContainers, you'll have to add the relevant dependencies to your project. The example code uses the build tool Gradle. Listing 1 shows how to declare the dependencies for the latest version of JUnit 5 and TestContainers. Both libraries are available on Maven Central or JCenter.

_build.gradle_
[source,groovy]
----
repositories {
    jcenter()
}

dependencies {
    def junitJupiterVersion = '5.3.1'
    testImplementation "org.junit.jupiter:junit-jupiter-api:$junitJupiterVersion"
    testImplementation "org.junit.jupiter:junit-jupiter-params:$junitJupiterVersion"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junitJupiterVersion"
    testImplementation 'org.testcontainers:junit-jupiter:1.10.1'
}
----

_Listing 1. Declaring the dependencies for JUnit Jupiter and TestContainers_

Next, you'll also need to configure test execution in Gradle.

== Configuring test execution

By default, Gradle picks JUnit 4.x as the default test framework. You'll have to explicitly call the method `useJUnitPlatform()` to switch to JUnit 5. When building the Docker image for a Java application, your test code will need to know where to find the JAR file of your application so Docker will be able to execute it. Given that test executed is dependent on the path used running the tests, you will also want to provide the name and absolute path to the JAR file. Listing 2 demonstrates the necessary setup for test execution of a Spring Boot application in a Gradle build. To ensure that the JAR file always contains the latest changes, the `test` tasks calls `assemble` first.

[source,groovy]
----
tasks.withType(Test) {
    useJUnitPlatform()
    systemProperty 'distribution.dir', bootJar.destinationDir
    systemProperty 'archive.name', bootJar.archiveName
}

test.dependsOn assemble
----

_Listing 2. Ensuring the proper setup for executing JUnit 5 tests with TestContainers_

The build should be ready to go. Let's have a look at the actual test implementation.

== Building and using a container as fixture in test

Our test class makes the following assumptions. The code under test represents a web service with endpoints for managing a To Do list. The test cases interact with those endpoints to verify the correct behavior by performing HTTP calls against them.

The TestContainers library provides a rich API for starting containers as test fixtures. The API includes functionality for building a Dockerfile, creating an image for it and starting a container. The test code in listing 3 does exactly that.

_ToDoWebServiceFunctionalTest.java_
[source,java]
----
@Testcontainers
public class ToDoWebServiceFunctionalTest {
    private final static File DISTRIBUTION_DIR = new File(System.getProperty("distribution.dir"));
    private final static String ARCHIVE_NAME = System.getProperty("archive.name");
    
    @Container
    private GenericContainer appContainer = createContainer();

    private static GenericContainer createContainer() {
        return new GenericContainer(buildImageDockerfile())
                .withExposedPorts(8080)
                .waitingFor(Wait.forHttp("/actuator/health")
                .forStatusCode(200));
    }

    private static ImageFromDockerfile buildImageDockerfile() {
        return new ImageFromDockerfile()
                .withFileFromFile(ARCHIVE_NAME, new File(DISTRIBUTION_DIR, ARCHIVE_NAME))
                .withDockerfileFromBuilder(builder -> builder
                        .from("openjdk:jre-alpine")
                        .copy(ARCHIVE_NAME, "/app/" + ARCHIVE_NAME)
                        .entryPoint("java", "-jar", "/app/" + ARCHIVE_NAME)
                        .build());
    }
}
----

_Listing 3. Creating and starting a container as test fixture_

I want to point out of a couple of interesting pieces in the listing. The Dockerfile looks fairly simple. It uses the base image named `openjdk:jre-alpine` to make the resuting image as small as possible. Then it copies the JAR file and points to it from the entrypoint. When starting the container, test execution blocks until the Spring Boot application becomes "healthy". In this case, the application uses https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready.html[Actuator] to expose an endpoint for the health check.

> Using the JAR file for running the application in a container may not be the most performant option. Every single change to the source code will result in having to rebuild the archive. The better alternative is to define the Dockerfile a way that creates a separate layers for external dependencies, resources files and class files. That way, Docker can cache layers that haven't changed from the previous execution. You will also want to disable the automatic deletion of images for TestContainers.

The actual test cases will need to target the container IP and mapped ports for making the HTTP calls. The `GenericContainer` class exposes method for retrieving the information. In listing 4, you can see how to build the endpoint URL.

_ToDoWebServiceFunctionalTest.java_
[source,java]
----
@Test
@DisplayName("can retrieve all items before and after inserting new ones")
void retrieveAllItems() {
    // Use endpoint URL provided by the method `#buildEndpointUrl(String)` to make HTTP calls
}

private URL buildEndpointUrl(String context) {
    StringBuilder url = new StringBuilder();
    url.append("http://");
    url.append(appContainer.getContainerIpAddress());
    url.append(":");
    url.append(appContainer.getFirstMappedPort());
    url.append(context);

    try {
        return new URL(url.toString());
    } catch (MalformedURLException e) {
        throw new RuntimeException("Invalid URL", e);
    }
}
----

_Listing 4. Builing the endpoint URL for the container_

Executing the test from the build works just fine. You've learned that we can pass in the relevant paths to the executable JAR file as a system property. But what about the IDE?

== Executing tests from the IDE

Developers live and breathe in their IDE. Unfortunately, the integration between the IDE and a build tool is not as tight as it could be leaving developers with having to come up with workarounds. If you'd execute the test case from the IDE, you'd run into an exception shown below when trying to resolve the system properties.

```
java.lang.ExceptionInInitializerError
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
Caused by: java.lang.NullPointerException
	at java.base/java.io.File.<init>(File.java:276)
	at com.bmuschko.todo.webservice.ToDoWebServiceFunctionalTest.<clinit>(ToDoWebServiceFunctionalTest.java:23)
	... 44 more
```

Even if you'd create the system properties, you'd still run into issues when changing the code. By default, test execution from the IDE doesn't create the JAR file. As a result, the latest changes wouldn't be reflected in the binary file. So what can you do to run the tests from the IDE. Really the only option you have at the moment is to delegate test execution to the build. In IntelliJ, this https://www.jetbrains.com/help/idea/gradle.html#delegate_build_gradle[setting is configurable].