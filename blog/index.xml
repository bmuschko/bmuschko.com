<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Benjamin Muschko&#39;s development blog</title>
    <link>https://bmuschko.com/blog/</link>
    <description>Recent content in Blogs on Benjamin Muschko&#39;s development blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://bmuschko.com/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Building Groovy with Bazel</title>
      <link>https://bmuschko.com/blog/bazel-groovy/</link>
      <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/bazel-groovy/</guid>
      <description>Bazel is a build automation tool that ships with support for a variety of languages out-of-the-box. For example, you can build Java projects right away without having to configure external functionality, so-called rules. Groovy is a popular language in the JVM space. As a developer, you&amp;#8217;d expect the following features:
   Compiling Groovy source code
  Creating a JAR file to bundle the class files
  Executing Groovy-based tests written with JUnit or Spock</description>
    </item>
    
    <item>
      <title>Crushing the Certified Jenkins Engineer (CJE) exam</title>
      <link>https://bmuschko.com/blog/cje-prep/</link>
      <pubDate>Thu, 30 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/cje-prep/</guid>
      <description>Last summer, I decided to take the Certified Jenkins Engineer (CJE) exam. I have years of experience with Jenkins as developer managing my own jobs as well as Jenkins administrator. Aquiring the certification sounded like a good idea to prove my proficiency with the subject. To pass the exam, you have to understand theoretical and practical aspects of CI/CD. The main focus of the certification lies on operating Jenkins pipelines and maintaining them in the context of a larger organization.</description>
    </item>
    
    <item>
      <title>Best practices for writing Jenkins shared libraries</title>
      <link>https://bmuschko.com/blog/jenkins-shared-libraries/</link>
      <pubDate>Thu, 31 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/jenkins-shared-libraries/</guid>
      <description>Introduction Pipeline definitions in Jenkins start small and maintainble. You write a Jenkinsfile that declares a couple of stages. Nothing dramatic, simple, understandable code. As your adoption of Jenkins and &#34;pipelines as code&#34; grows within the organization, you&amp;#8217;ll find out that other teams are copy-pasting pipeline code all over the place. What works for one project should work for other projects, right?! Soon requirements become more complex and your organization will enter a world of pain of unmaintainable, duplicated code.</description>
    </item>
    
    <item>
      <title>Crushing the Certified Kubernetes Application Developer (CKAD) exam</title>
      <link>https://bmuschko.com/blog/ckad-prep/</link>
      <pubDate>Sun, 04 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/ckad-prep/</guid>
      <description>I recently decided the take the Certified Kubernetes Application Developer (CKAD) exam. Unlike other certification exams, the CKAD exam is 100% hands-on. You are not expected to select one or many answers from a multiple choice question but instead solve problems on a Kubernetes cluster. Each question focuses on a practical aspect of Kubernetes and applying it to real-world use cases. By passing the exam, you demonstrated practical proficiency with Kubernetes concepts in the role of an application developer.</description>
    </item>
    
    <item>
      <title>Writing your first kubectl plugin with Go</title>
      <link>https://bmuschko.com/blog/writing-your-first-kubectl-plugin/</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/writing-your-first-kubectl-plugin/</guid>
      <description>The kubectl command line tool offers a powerful, client-side mechanism for communicating with the Kubernetes API server. kubectl comes with a lot of fine-grained commands, subcommands and options. Getting familiar with all of these options takes practice and time.
 Despite its wide array of options, you sometimes wish that kubectl would provide higher-level functions or would simplify specific operations. For example, you may have to shell into a running container to inspect the environment in interactive mode.</description>
    </item>
    
    <item>
      <title>Building Go projects using modules on Jenkins</title>
      <link>https://bmuschko.com/blog/go-on-jenkins/</link>
      <pubDate>Fri, 25 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/go-on-jenkins/</guid>
      <description>The Go 1.11 release introduced experimental, opt-in support for Go modules. It is now possible to build Go projects outside of the $GOPATH. This profound change has a significant impact on developer workflows. For example, you don&amp;#8217;t have to set up the expected directory structure anymore just because you want to fix a simple bug in an open source package. Furthermore, CI processes can clone the code and run the Go command directly from the checkout directory.</description>
    </item>
    
    <item>
      <title>Writing, testing and publishing an AsciidoctorJ extension</title>
      <link>https://bmuschko.com/blog/asciidoctorj-extension/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/asciidoctorj-extension/</guid>
      <description>Asciidoc is a powerful markup language and extensible platform for producing documentation. Sometimes the requirements for producing documentation go beyond its built-in capabilities. Asciidoc enabled content producers to enhance the basic functionality of the platform by writing so-called extensions - think plugin for Asciidoc.
 AsciidoctorJ is the library for running Asciidoctor on the JVM. It comes into play when converting Asciidoc content to the target format (e.g. HTML) from Java.</description>
    </item>
    
    <item>
      <title>Testing a Java project with TestContainers on JUnit 5</title>
      <link>https://bmuschko.com/blog/java-project-testcontainers/</link>
      <pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/java-project-testcontainers/</guid>
      <description>TestContainers is a helpful tool for writing integration and functional tests with Docker containers as fixtures. Starting with version 1.10.0, the Java library of TestContainers supports writing and executing tests with JUnit 5, a feature long-awaited by the community. Time to explore the functionality by example!
 In this blog post, you will learn how to build an image for a Java application on-the-fly, start up a container as test fixture and stop it after the test has finished.</description>
    </item>
    
    <item>
      <title>Injecting credentials into a Docker container running a Spring Boot application</title>
      <link>https://bmuschko.com/blog/docker-secret-spring-boot/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/docker-secret-spring-boot/</guid>
      <description>The profile concept in Spring Boot makes is extremely easy to provide configuration specific to a runtime environment. A typical setup might include configuration for the local development environment, a testing environment, staging and production. All you need to do is to provide a properties files per environment on the classpath e.g. application-dev.properties and application-prod.properties. At runtime, you can tell Spring Boot which profile to pick via command line option or environment variable.</description>
    </item>
    
    <item>
      <title>Containerization workflow for Java apps with Jib</title>
      <link>https://bmuschko.com/blog/containerization-with-jib/</link>
      <pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/containerization-with-jib/</guid>
      <description>Containerizing a Java application is the natural extension to building a plain, executable JAR file: &#34;write once, run everywhere&#34;. Creating an optimized image for an application is far from straightforward and requires in-depth knowledge of Docker concepts and best practices.
 A typical developer worflow involves the following steps. First, you start out by writing a Dockerfile with the goal of producing an image small in size while at the same time ensuring cacheability of layers as much as possible.</description>
    </item>
    
    <item>
      <title>Exploring the landscape of Go testing frameworks</title>
      <link>https://bmuschko.com/blog/go-testing-frameworks/</link>
      <pubDate>Wed, 13 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/go-testing-frameworks/</guid>
      <description>Recently, JetBrains ran a survey on the state of developer ecosystems. As part of the survey, they asked Go developers about their tools of choice. As I was reading through it, the section on testing frameworks caught my eye. So far I had only used the built-in Go testing support and Testify for my own projects. Time to explore the testing landscape!
 During my research I tried to identify the most popular packages and differentiate them in regards to feature set, usability and expressiveness.</description>
    </item>
    
    <item>
      <title>Migrating from Glide to dep</title>
      <link>https://bmuschko.com/blog/migrating-glide-to-dep/</link>
      <pubDate>Sat, 26 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/migrating-glide-to-dep/</guid>
      <description>Package management is a bread-and-butter task. Rarely does a Go developer write a Go program that doesn&amp;#8217;t reference an external package. Over the course of the years, the Go community has seen various approaches to solving the same problem. From go get over vendoring to package managers like Glide. Each solution comes with its benefits and drawbacks.
 Recently, the Go community settled on dep as the canonical tool for package management.</description>
    </item>
    
    <item>
      <title>Implementing an intuitive versioning and release strategy</title>
      <link>https://bmuschko.com/blog/gradle-release-strategy/</link>
      <pubDate>Thu, 17 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/gradle-release-strategy/</guid>
      <description>Implementing a versioning and release strategy for a project can be daunting task. An effective strategy should be elegant and require little manual intervention. When forming a strategy the following factors need to be taken under consideration.
   What kind of artifact(s) does your project produce? Maybe you are writing a library or a full-fledged application comprised of multiple components.
  How often do you usually release your project?</description>
    </item>
    
    <item>
      <title>Starting a new chapter...</title>
      <link>https://bmuschko.com/blog/starting-a-new-chapter/</link>
      <pubDate>Mon, 14 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/starting-a-new-chapter/</guid>
      <description>The news has been out for over two weeks, but I just got around to writing a blog post about it. April 30th marked my last day at Gradle Inc., the company behind the open source build tool Gradle and Gradle Enterprise, the complimentary commercial offering.
 It&amp;#8217;s been almost 5 years full of challenges and learning experiences. Over the course of that time, I had the opportunity to help several companies migrate their build environment to Gradle and adopt Continuous Delivery in the process.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Getting started with Docker Compose</title>
      <link>https://bmuschko.com/blog/gradle-docker-compose/</link>
      <pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/gradle-docker-compose/</guid>
      <description>Docker Compose is a tool for defining and running entire application stacks in containers. Gradle plays well with Docker Compose and can automate the bootstrapping of those containers from the build process. In a previous post, I discussed how to use Gradle to start and stop a Docker container for integration testing. In this blog post, I want to continue the discussion by explaining how to manage multiple containers with Compose.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Writing a Node.js convention plugin</title>
      <link>https://bmuschko.com/blog/gradle-docker-convention-plugin/</link>
      <pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/gradle-docker-convention-plugin/</guid>
      <description>The Gradle Docker plugin provides turnkey solutions to common use cases. In the previous blog posts of the series &#34;Docker with Gradle&#34;, we looked at creating a Docker image for a Spring Boot application and how to use the image as fixture for integration testing. If you read the articles, you might have noticed that the plugin capabilities are flexible enough to model different situations. Nevertheless, this approach can easily become tedious if you want to use it across multiple, independent projects.</description>
    </item>
    
    <item>
      <title>Easy Gradle project generation</title>
      <link>https://bmuschko.com/blog/gradle-project-generation/</link>
      <pubDate>Tue, 06 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/gradle-project-generation/</guid>
      <description>Having to create a build.gradle file, a settings.gradle file and the necessary project layout manually for ever new Gradle project can be a drag. Gradle provides the build init plugin for generating new projects with different flavors from the command line. The downside of this approach is that you already have to have the Gradle runtime installed on your machine. You will likely also have to look up the right combination of command line options from the user manual.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Integration testing using containers</title>
      <link>https://bmuschko.com/blog/docker-integration-testing/</link>
      <pubDate>Sun, 18 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/docker-integration-testing/</guid>
      <description>In the first blog post on &#34;Docker with Gradle&#34; you learned how to package a Spring Boot application as a Docker image. After verifying that the image works as expected you pushed the image to a registry. Being able to produce and push a new image of an application with every single commit lays the foundation for enabling supplemental automation workflows.
 Integration testing plays an important role in the software development lifecycle to ensure functional and non-functional requirements have been met.</description>
    </item>
    
    <item>
      <title>Docker with Gradle: Dockerizing a Spring Boot application</title>
      <link>https://bmuschko.com/blog/dockerized-spring-boot-app/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/dockerized-spring-boot-app/</guid>
      <description>The use of Docker has become widespread among companies big and small for a variety scenarios. Executing Docker from the command line for simple tasks is easy and becomes routine as soon as you get a hang of it. Having to enter Docker commands for a whole workflow can become tedious. It seems obvious that you might want to integrate Docker into an automated process for convenience and reproducibility. Gradle can help with defining and executing such a process with the help of the Docker plugin.</description>
    </item>
    
    <item>
      <title>JUnit 5 vs. Spock feature showdown</title>
      <link>https://bmuschko.com/blog/junit5-vs-spock-showdown/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/junit5-vs-spock-showdown/</guid>
      <description>Introduction For over a decade JUnit 4 has been the go-to test framework for JVM-based software projects. You can find the use of JUnit across the board in organizations from big entprises to small startups. Despite its popularity, the test framework&amp;#8217;s features barely moved with the times. Due to its deep penetration among the industry, evolutionary changes became harder and harder to implement without introducing inevidable breakages to the API.</description>
    </item>
    
    <item>
      <title>Build pipelines with Jenkins 2 by example</title>
      <link>https://bmuschko.com/blog/jenkins-build-pipeline/</link>
      <pubDate>Mon, 30 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/jenkins-build-pipeline/</guid>
      <description>Introduction Jenkins World 2017 came to a close in late September. Time to revisit the improvements that have been made to the support for build pipelines. I am no stranger to using Jenkins to model a Continuous Delivery pipeline. In the dark ages, you had to construct a pipeline with the help of different Jenkins plugins bit by bit. The approach was highly brittle, inconsistent and full of magical tips and tricks.</description>
    </item>
    
    <item>
      <title>Building Go with Gradle</title>
      <link>https://bmuschko.com/blog/golang-with-gradle/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/golang-with-gradle/</guid>
      <description>Introduction In July 2017 Google Go made a big jump on the TIOBE index. It&amp;#8217;s now ranked among the top 10 most popular programming languages. With the rise of Moby aka Docker, Kubernetes and InfluxDB the language has become the go-to tool in the DevOps space. The complexity of automating the process of building, assembling and distributing the source code and binaries for any medium- to large-sized project is high. It&amp;#8217;s somewhat shocking to see that the predominant tooling of automating in Go is still a mixture of Make files and shell scripts as it can be observed in the Moby and Kubernetes code base.</description>
    </item>
    
    <item>
      <title>So you want to write a tech book...</title>
      <link>https://bmuschko.com/blog/writing-tech-book/</link>
      <pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/writing-tech-book/</guid>
      <description>You are a published author. Your family and friends are super proud of you and co-workers admire your perseverance, hard work and deep technical knowledge. Being an author looks great on the resume and companies are eager to hire you (it must be worth a higher salary right?). That&amp;#8217;s the dream you set out to achieve: writing a technical book on an area of knowledge you are passionate about. Unfortunately, you haven&amp;#8217;t started writing yet and you are still looking for a publisher for your work.</description>
    </item>
    
    <item>
      <title>Publishing Javadocs with Gradle</title>
      <link>https://bmuschko.com/blog/publishing-javadocs/</link>
      <pubDate>Sun, 21 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://bmuschko.com/blog/publishing-javadocs/</guid>
      <description>Introduction Documentation is a must-have for any consumer-facing project. It can come in different shapes and sizes: documentation about the functionality of the project, DSL documentation, API documentation, usage examples and many more. For consumers of libraries the relevant part of the documentation often is the exposed API. In the Java world, API documentation materializes as Javadocs.
 Java provides the javadoc tool for generating Javadocs documentation from source code. Running the tool is a no-brainer either from the command line or as an integration with any of the build tools available, like Ant, Maven or Gradle.</description>
    </item>
    
  </channel>
</rss>