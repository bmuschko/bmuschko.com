<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="map[]" />
    
    <link rel="shortcut icon" type="image/x-icon" href="https://bmuschko.com/img/favicon.ico">
    <title>Docker with Gradle: Writing a Node.js convention plugin</title>
    <meta name="generator" content="Hugo 0.84.0" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://bmuschko.com/css/main.css" /><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/darcula.min.css">
    
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,200bold,400old" />
    
    <!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->

    
        
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-99678333-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
    
  </head>

  <body>
    <div id="wrap">

      
      <nav class="navbar navbar-default">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://bmuschko.com/"><i class="fa fa-home"></i></a>
    </div>
    <div id="navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
        <li><a href="/blog/">BLOG</a></li>
        
        <li><a href="/talks/">TALKS</a></li>
        
      
      </ul>
    </div>
  </div>
</nav>

      <div class="container">
        <div class="blog-post">
          <h3>
            <strong><a href="https://bmuschko.com/blog/gradle-docker-convention-plugin/">Docker with Gradle: Writing a Node.js convention plugin</a></strong>
          </h3>
        </div>
        <div class="blog-title">
          <h4>
            
            <span class="label label-success">build</span>
            
            <span class="label label-success">docker</span>
            
            <span class="label label-success">container</span>
            
            <span class="label label-success">nodejs</span>
            
            <span class="label label-success">javascript</span>
            
            <span class="label label-success">gradle</span>
            
            <span class="label label-success">plugin</span>
            
            </br></br></br>
            March 28, 2018
          </h4>
        </div>
        <div class="panel panel-default">
          <div class="panel-body">
            <div class="blogpost">
              <div class="paragraph">
<p>The Gradle Docker plugin provides turnkey solutions to common use cases. In the previous blog posts of the series &#34;Docker with Gradle&#34;, we looked at creating a <a href="http://bmuschko.com/blog/dockerized-spring-boot-app/">Docker image for a Spring Boot application</a> and how to use the image as <a href="http://bmuschko.com/blog/docker-integration-testing/">fixture for integration testing</a>. If you read the articles, you might have noticed that the plugin capabilities are flexible enough to model different situations. Nevertheless, this approach can easily become tedious if you want to use it across multiple, independent projects. Gradle promotes the idea of reusibility and encapsulation. Plugins embody the preferred way to implement those non-functionality requirements.</p>
</div>
<div class="paragraph">
<p>In this post, you will learn how to enhance the basic capabilities of the Gradle Docker plugin to establish conventions for your own projects. As an example, we will have a look at a very simpilistic Node.js application built and run by Gradle and packaged as Docker image.</p>
</div>
<div class="paragraph">
<p>To understand the content, you won’t need to have proficient knowledge of Node.js nor Javascript. The main objective of this post is to demonstrate the concept <a href="https://guides.gradle.org/designing-gradle-plugins/#capabilities-vs-conventions">plugin composition</a> and how to establish opinionated conventions. You can find the <a href="https://github.com/bmuschko/gradle-docker-convention-plugin">full source code</a> on GitHub. I would recommend reading up on the most important <a href="https://guides.gradle.org/designing-gradle-plugins/">design considerations</a> and <a href="https://guides.gradle.org/implementing-gradle-plugins/">implementation concepts</a> if you are just starting out with plugin development.</p>
</div>
<hr/>
<div class="sect1">
<h2 id="_building_a_node_js_application_with_gradle">Building a Node.js application with Gradle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle is a polyglot build tool and supports building other languages than just Java as long as there’s a plugin for it. The <a href="https://github.com/srs/gradle-node-plugin">Node plugin</a> supports the full lifecycle of a modern Javascript application. It even takes care of installing Node.js and NPM packages at runtime without manual intervention. The following build script shows how to apply the plugin and configure it to use a specific Node.js version. The script also adds a task for executing a Node.js script as the main entry point.</p>
</div>
<div class="paragraph">
<p><em>application/build.gradle</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    repositories {
        maven {
            url &#39;https://plugins.gradle.org/m2/&#39;
        }
    }
    dependencies {
        classpath &#39;com.moowork.gradle:gradle-node-plugin:1.2.0&#39;
    }
}

apply plugin: &#39;com.moowork.node&#39;

version = &#39;1.0.0&#39;
group = &#39;com.bmuschko&#39;

node {
    version = &#39;9.8.0&#39;
    download = true
}

task helloWorld(type: NodeTask) {
    dependsOn npmInstall
    script = file(&#39;src/node/index.js&#39;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 1. Applying and configuring the Gradle Node plugin</em></p>
</div>
<div class="paragraph">
<p>The task <code>helloWorld</code> points to the Javascript file <code>src/node/index.js</code> when executed. Judging by the name, it should print a &#34;Hello World&#34; message to the console. The index file uses the NPM package <a href="https://www.npmjs.com/package/figlet">figlet</a> to make the output visually appealing.</p>
</div>
<div class="paragraph">
<p><em>application/src/node.index.js</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const figlet = require(&#39;figlet&#39;);

var out = figlet.textSync(&#39;Hello World!&#39;, {
    font: &#39;Standard&#39;
});

console.log(out);</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 2. A simple Node.js application</em></p>
</div>
<div class="paragraph">
<p>Executing the task produces the following output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">./gradlew helloWorld

&gt; Task :helloWorld
  _   _      _ _        __        __         _     _ _
 | | | | ___| | | ___   \ \      / /__  _ __| | __| | |
 | |_| |/ _ \ | |/ _ \   \ \ /\ / / _ \| &#39;__| |/ _` | |
 |  _  |  __/ | | (_) |   \ V  V / (_) | |  | | (_| |_|
 |_| |_|\___|_|_|\___/     \_/\_/ \___/|_|  |_|\__,_(_)

 BUILD SUCCESSFUL in 3s
 3 actionable tasks: 1 executed, 2 up-to-date</code></pre>
</div>
</div>
<div class="paragraph">
<p>Neat, you got your first Node.js application up and running without having to resort to a Javascript-based build tool like Grunt or Gulp.</p>
</div>
<div class="paragraph">
<p>Let’s also inspect the application’s <code>package.json</code> file. As you can see in the listing below, we provided a name, a version and a description for the application. Most importantly, the file also declares the NPM dependency. Now, it’s a good idea to also check in a <a href="https://github.com/bmuschko/gradle-docker-convention-plugin/blob/master/application/package-lock.json">package lock file</a> to ensure that the same dependency version is resolved whenver the build is executed.</p>
</div>
<div class="paragraph">
<p><em>application/package.json</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  &#34;name&#34;: &#34;nodejs-hello-world&#34;,
  &#34;version&#34;: &#34;1.0.0&#34;,
  &#34;description&#34;: &#34;Prints hello world message&#34;,
  &#34;private&#34;: true,
  &#34;license&#34;: &#34;Apache License 2.0&#34;,
  &#34;repository&#34;: {
    &#34;type&#34;: &#34;git&#34;,
    &#34;url&#34;: &#34;https://github.com/bmuschko/gradle-docker-convention-plugin&#34;
  },
  &#34;dependencies&#34;: {
    &#34;figlet&#34;: &#34;^1.2.0&#34;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 3. The application’s package file</em></p>
</div>
<div class="paragraph">
<p>So far the application has no touch point with Docker. In the next section, you will set up the infrastructure for building a Gradle plugin for the purpose of creating a Docker image for the application and pushing it to DockerHub.</p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_creating_the_basic_plugin_infrastructure">Creating the basic plugin infrastructure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It’s a good idea to implement a Gradle plugin as a standalone project to simplify the process of publishing it to a binary repository later. As part of this blog post, you are only going to build the plugin as part of a composite build. Usually, you’d go the additional mile and publish the artifact(s) so that it can be reused by other, independent projects. The following directory structure separates the plugin implementation from the actual application using it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ tree
.
├── application
└── plugin</pre>
</div>
</div>
<div class="paragraph">
<p>Getting started with writing a plugin looks very similar in most cases: create a <code>build.gradle</code> file, apply the <a href="https://guides.gradle.org/implementing-gradle-plugins/#plugin-development-plugin">Java Gradle Plugin Development plugin</a> and declare any dependencies needed to build the project.</p>
</div>
<div class="paragraph">
<p>In this case, you will also want to build upon the capabilities provided by the Gradle Docker plugin. The build script declares a dependency on version 3.2.5. You might have guessed that the plugin code will be writting in the language Groovy as the <code>groovy</code> plugin has been applied as well.</p>
</div>
<div class="paragraph">
<p><em>plugin/build.gradle</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">apply plugin: &#39;groovy&#39;
apply plugin: &#39;java-gradle-plugin&#39;

version = &#39;0.1&#39;
group = &#39;com.bmuschko&#39;

ext.compatibilityVersion = &#39;1.6&#39;
sourceCompatibility = compatibilityVersion
targetCompatibility = compatibilityVersion

repositories {
    jcenter()
}

dependencies {
    compile &#39;com.bmuschko:gradle-docker-plugin:3.2.5&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 4. Setting up the plugin’s build script</em></p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementing_the_plugin_class">Implementing the plugin class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let’s talk about the requirements for the plugin before we get down to the actual implementation. In a nutshell the following aspects should be covered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The plugin should be able to use task types provided by the Docker plugin.</p>
</li>
<li>
<p>The workflow should be able to create a Dockerfile, build an image and push it to DockerHub.</p>
</li>
<li>
<p>The plugin should introduce conventions so that the user can work with sensitive defaults.</p>
</li>
<li>
<p>A user should be able to configure essential runtime behavior like the base image or the exposed ports of the container.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Listing 5 shows a plugin class that fulfills all of those requirements.</p>
</div>
<div class="paragraph">
<p><em>DockerNodeJsApplicationPlugin.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package com.bmuschko.gradle.docker

import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.tasks.Sync

class DockerNodeJsApplicationPlugin implements Plugin&lt;Project&gt; {
    public static final String NODE_JS_APPLICATION_EXTENSION_NAME = &#39;nodeJsApplication&#39;
    public static final String DOCKERFILE_TASK_NAME = &#39;createDockerfile&#39;
    public static final String SYNC_DIST_RESOURCES_TASK_NAME = &#39;syncNodeFiles&#39;
    public static final String BUILD_IMAGE_TASK_NAME = &#39;buildImage&#39;
    public static final String PUSH_IMAGE_TASK_NAME = &#39;pushImage&#39;

    @Override
    void apply(Project project) {
        project.apply(plugin: DockerRemoteApiPlugin)

        DockerExtension dockerExtension = project.extensions.getByType(DockerExtension)
        DockerNodeJsApplication dockerNodeJsApplication = dockerExtension.extensions.create(NODE_JS_APPLICATION_EXTENSION_NAME, DockerNodeJsApplication)

        Dockerfile createDockerfileTask = createDockerfileTask(project, dockerNodeJsApplication)
        Sync distSyncTask = createDistSyncResourcesTask(project, createDockerfileTask)
        createDockerfileTask.dependsOn distSyncTask
        DockerBuildImage dockerBuildImageTask = createBuildImageTask(project, createDockerfileTask, dockerNodeJsApplication)
        createPushImageTask(project, dockerBuildImageTask)
    }

    private Dockerfile createDockerfileTask(Project project, DockerNodeJsApplication dockerNodeJsApplication) {
        project.task(DOCKERFILE_TASK_NAME, type: Dockerfile) {
            description = &#39;Creates the Docker image for the Node.js application.&#39;
            from { dockerNodeJsApplication.baseImage }
            copyFile(&#39;package*.json&#39;, &#39;./&#39;)
            copyFile(&#39;index.js&#39;, &#39;/index.js&#39;)
            runCommand(&#39;npm install&#39;)
            entryPoint(&#39;node&#39;, &#39;index.js&#39;)
            exposePort { dockerNodeJsApplication.ports }
        }
    }

    private Sync createDistSyncResourcesTask(Project project, Dockerfile createDockerfileTask) {
        project.task(SYNC_DIST_RESOURCES_TASK_NAME, type: Sync) {
            description = &#34;Copies the distribution resources to a temporary directory.&#34;
            from(&#39;.&#39;) {
                include &#39;package*.json&#39;
            }
            from &#39;src/node&#39;
            into createDockerfileTask.destFile.parentFile
        }
    }

    private DockerBuildImage createBuildImageTask(Project project, Dockerfile createDockerfileTask, DockerNodeJsApplication dockerNodeJsApplication) {
        project.task(BUILD_IMAGE_TASK_NAME, type: DockerBuildImage) {
            description = &#39;Builds the Docker image for the Node.js application.&#39;
            dependsOn createDockerfileTask
            conventionMapping.inputDir = { createDockerfileTask.destFile.parentFile }
            conventionMapping.tag = { dockerNodeJsApplication.getTag() }
        }
    }

    private void createPushImageTask(Project project, DockerBuildImage dockerBuildImageTask) {
        project.task(PUSH_IMAGE_TASK_NAME, type: DockerPushImage) {
            description = &#39;Pushes created Docker image to the repository.&#39;
            dependsOn dockerBuildImageTask
            conventionMapping.imageName = { dockerBuildImageTask.getTag() }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 5. The convention plugin implementation</em></p>
</div>
<div class="paragraph">
<p>We will disect the most important aspects of this rather lengthy code snippet. First of all, the plugin applies the <code>DockerRemoteApiPlugin</code> which brings the basic Docker capabilities. Most of the tasks created by the plugin rely on the task types introduced by the Docker plugin.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/blog/gradle-docker-convention-plugin/plugin-composition.png" alt="plugin composition"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 1. Building upon the capabilities of the Docker plugin</em></p>
</div>
<div class="paragraph">
<p>The plugin creates four tasks and establishes the proper dependencies between them to form a meaninful lifecycle. For example, executing the task <code>pushImage</code> takes care of building the image first.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/blog/gradle-docker-convention-plugin/task-dependencies.png" alt="task dependencies"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 2. The tasks and their dependencies created by the plugin</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>createDockerfile</code>: Creates the Dockerfile using default conventions.</p>
</li>
<li>
<p><code>syncNodeFiles</code>: Synchronizes the Node.js files of the application with a target directory for packaging.</p>
</li>
<li>
<p><code>buildImage</code>: Builds the image of the Node.js application from the Dockerfile.</p>
</li>
<li>
<p><code>pushImage</code>: Pushes the image to DockerHub.</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>You might be familiar with the concept of convention mapping used by this plugin. Convention mapping is an internal Gradle API which allows plugin developers to defer the evaluation of a property value until it is actually needed. At the time of writing, the Docker plugin does not use the public and recommended <a href="https://docs.gradle.org/current/userguide/lazy_configuration.html">Provider API</a> yet. For more information, follow this <a href="https://github.com/bmuschko/gradle-docker-plugin/issues/561">issue</a>.</p>
</div>
</blockquote>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_exposing_a_custom_dsl_for_configuring_runtime_behavior">Exposing a custom DSL for configuring runtime behavior</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Plugins should give users the ability to reconfigure default conventions if they don’t fit the project’s needs. The extension <code>DockerNodeJsApplication</code> exposes a <a href="https://guides.gradle.org/implementing-gradle-plugins/#modeling_dsl_like_apis">custom DSL</a> for configuring the base image, exposed container ports and the tag used for the produced image. As you can see in listing 6, most properties already come with a default value.</p>
</div>
<div class="paragraph">
<p><em>DockerNodeJsApplication.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package com.bmuschko.gradle.docker

class DockerNodeJsApplication {
    String baseImage = &#39;node:9&#39;
    Set&lt;Integer&gt; ports = [8080]
    String tag
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 6. The extension exposed by the plugin</em></p>
</div>
<div class="paragraph">
<p>The plugin implementation in listing 5 registers the <code>DockerNodeJsApplication</code> extension. You might not have noticed that the extension hooks into the existing Docker plugin extension. It creates an extension for an extension. That may sound complicated but leads to a seamless enhancement of the existing Docker plugin DSL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">DockerExtension dockerExtension = project.extensions.getByType(DockerExtension)
DockerNodeJsApplication dockerNodeJsApplication = dockerExtension.extensions.create(NODE_JS_APPLICATION_EXTENSION_NAME, DockerNodeJsApplication)</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 7. Enhancing the extension of the Docker plugin</em></p>
</div>
<div class="paragraph">
<p>Next, you will see how simple the actual build script looks like to the end user.</p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_plugin_in_the_application_project">Using the plugin in the application project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It’s time to bring it all together. At the moment the plugin is <a href="https://plugins.gradle.org/search?term=bmuschko+docker">not available on the Gradle plugin portal</a> though I am considering making it part of the Docker plugin suite if more people are interested. Let me know what you think!</p>
</div>
<div class="paragraph">
<p><em>application/build.gradle</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    repositories {
        maven {
            url &#39;https://plugins.gradle.org/m2/&#39;
        }
    }
    dependencies {
        classpath &#39;com.bmuschko:gradle-docker-nodejs-plugin:0.1&#39;
    }
}

apply plugin: &#39;com.bmuschko.docker-nodejs-application&#39;

docker {
    registryCredentials {
        username = getConfigurationProperty(&#39;DOCKER_USERNAME&#39;, &#39;docker.username&#39;)
        password = getConfigurationProperty(&#39;DOCKER_PASSWORD&#39;, &#39;docker.password&#39;)
        email = getConfigurationProperty(&#39;DOCKER_EMAIL&#39;, &#39;docker.email&#39;)
    }

    nodeJsApplication {
        tag = &#34;bmuschko/nodejs-hello-world:$project.version&#34;
    }
}

String getConfigurationProperty(String envVar, String sysProp) {
    System.getenv(envVar) ?: project.findProperty(sysProp)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 8. A build script applying and configuring the Docker Node.js plugin</em></p>
</div>
<div class="paragraph">
<p>Let’s see the process in action. For the purpose of demonstration you can use composite builds to skip the step of publishing the plugin to a binary repository. Just navigate to the directory <code>application</code> and run the command <code>./gradlew --include-build ../plugin pushImage</code>.</p>
</div>
<a href="https://asciinema.org/a/172633" target="_blank"><img src="https://asciinema.org/a/172633.png"/></a>
<br/><br/>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Implementing a convention plugin has a lot of benefits. First of all, the plugin encapsulates complex and imperative logic. As a result, the consuming build script becomes less cluttered with implementation details. Default conventions provide sensible defaults applicable to most users. Declarative custom language elements expose an &#34;user interface&#34; to control the runtime behavior and can seemlessly blend in with the Gradle core DSL.</p>
</div>
</div>
</div>

              <hr>
              <div class="related-posts">
                <h5>Related Posts</h5>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        February 1, 2020
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/bazel-groovy/">Building Groovy with Bazel</a></strong>
                      </h6>
                    </div>
                  </div>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        October 31, 2019
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/jenkins-shared-libraries/">Best practices for writing Jenkins shared libraries</a></strong>
                      </h6>
                    </div>
                  </div>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        June 20, 2019
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/writing-your-first-kubectl-plugin/">Writing your first kubectl plugin with Go</a></strong>
                      </h6>
                    </div>
                  </div>
                
              </div>
            </div>
          </div>
          <hr>
        <div class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">

    (function() {
      
      
      if (window.location.hostname == "localhost")
        return;

      var disqus_shortname = 'bmuschko-com';
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
        </div>
      </div>
    </div>

    
    <footer>
  <div id="footer">
    <div class="container">
      <p class="text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io/">Hugo</a> and
      <a href="http://www.github.com/nurlansu/hugo-sustain/">sustain</a> with ♥</p>
    </div>
  </div>
</footer>
<div class="footer"></div>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://bmuschko.com/js/docs.min.js"></script>
<script src="https://bmuschko.com/js/main.js"></script>

<script src="https://bmuschko.com/js/ie10-viewport-bug-workaround.js"></script><!-- Syntax highlighting -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/shell.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/groovy.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



    
  </body>
</html>
