<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="map[]" />
    
    <link rel="shortcut icon" type="image/x-icon" href="https://bmuschko.com/img/favicon.ico">
    <title>JUnit 5 vs. Spock feature showdown</title>
    <meta name="generator" content="Hugo 0.84.0" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://bmuschko.com/css/main.css" /><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/darcula.min.css">
    
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,200bold,400old" />
    
    <!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->

    
        
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-99678333-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
    
  </head>

  <body>
    <div id="wrap">

      
      <nav class="navbar navbar-default">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://bmuschko.com/"><i class="fa fa-home"></i></a>
    </div>
    <div id="navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
        <li><a href="/blog/">BLOG</a></li>
        
        <li><a href="/talks/">TALKS</a></li>
        
      
      </ul>
    </div>
  </div>
</nav>

      <div class="container">
        <div class="blog-post">
          <h3>
            <strong><a href="https://bmuschko.com/blog/junit5-vs-spock-showdown/">JUnit 5 vs. Spock feature showdown</a></strong>
          </h3>
        </div>
        <div class="blog-title">
          <h4>
            
            <span class="label label-success">junit5</span>
            
            <span class="label label-success">spock</span>
            
            <span class="label label-success">testing</span>
            
            <span class="label label-success">mock</span>
            
            <span class="label label-success">mockito</span>
            
            </br></br></br>
            January 1, 2018
          </h4>
        </div>
        <div class="panel panel-default">
          <div class="panel-body">
            <div class="blogpost">
              <div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For over a decade <a href="http://junit.org/junit4/">JUnit 4</a> has been the go-to test framework for JVM-based software projects. You can find the use of JUnit across the board in organizations from big entprises to small startups. Despite its popularity, the test framework’s features barely moved with the times. Due to its deep penetration among the industry, evolutionary changes became harder and harder to implement without introducing inevidable breakages to the API.</p>
</div>
<div class="paragraph">
<p>With the rise of newer JVM languages like Groovy and Kotlin, feature-rich test frameworks emerged. The test framework <a href="http://spockframework.org/">Spock</a> became a welcome alternative for many projects fearless to adopt Groovy as part of their polyglot software stack.</p>
</div>
<div class="paragraph">
<p>With the <a href="http://junit.org/junit5/docs/current/user-guide/#release-notes-5.0.0">first GA release of JUnit 5</a> in September 2017, the JUnit team brought real innovation to the established space of testing JVM code. Not only is the release packed with new features comparable to the ones provided by Spock, JUnit 5 also serves as a platform for <a href="http://junit.org/junit5/docs/current/user-guide/#launcher-api">launching other test frameworks</a> on the JVM.</p>
</div>
<div class="paragraph">
<p>In this blog post, I am going to compare typical testing usage patterns and features available for JUnit 5 and Spock. The content is not going to discuss the fundamental, methodological differences between JUnit 5 and Spock (<a href="https://en.wikipedia.org/wiki/Behavior-driven_development">behavior-driven development (BDD)</a> vs. non-BDD). You can find all sample code in a <a href="https://github.com/bmuschko/junit5-vs-spock-feature-comparison">dedicated repository on Github</a>. All examples are based on JUnit 5.0.2 and Spock 1.1.</p>
</div>
<div class="paragraph">
<p>For a quick reference, you can directly jump to a specific test framework feature:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#test-execution">Test execution</a></p>
</li>
<li>
<p><a href="#fixture-setup-teardown">Fixture set up and tear down</a></p>
</li>
<li>
<p><a href="#descriptive-test-names">Descriptive test names</a></p>
</li>
<li>
<p><a href="#disabling-tests">Disabling tests</a></p>
</li>
<li>
<p><a href="#expecting-thrown-exceptions">Expecting thrown exceptions</a></p>
</li>
<li>
<p><a href="#repeating-test-execution">Repeating test execution</a></p>
</li>
<li>
<p><a href="#declaring-timeouts">Declaring test execution timeouts</a></p>
</li>
<li>
<p><a href="#conditional-test-execution">Conditional test execution</a></p>
</li>
<li>
<p><a href="#data-driven-tests">Data-driven tests</a></p>
</li>
<li>
<p><a href="#mocking">Mocking</a></p>
</li>
<li>
<p><a href="#labeling-filtering">Labeling and filtering test execution</a></p>
</li>
<li>
<p><a href="#extending-test-framework">Extending the test framework</a></p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_code_under_test">Code under test</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For the purpose of demonstrating the capabilities of both test frameworks, we’ll use two sets of classes and/or interfaces. The simplest class provides methods for executing arithmetic operations shown in listing 1. Most test framework features in this post can be demonstrated with the help of <code>ArithmeticOperation.java</code>.</p>
</div>
<div class="paragraph">
<p><em>ArithmeticOperation.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ArithmeticOperation {
    public int add(int a, int b) {
        return a + b;
    }

    public int substract(int a, int b) {
        return a - b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }

    public double divide(int a, int b) {
        return a / b;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 1. Class implementing artithmetic operations</em></p>
</div>
<div class="paragraph">
<p>More advanced testing capabilities e.g. code that throws an exception require a slightly more complex setup. The following interface and class read the contents of a file for a given <code>Path</code> instance.</p>
</div>
<div class="paragraph">
<p><em>FileReader.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.IOException;

public interface FileReader {
    String readContent(Path path) throws IOException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 2. File reader interface</em></p>
</div>
<div class="paragraph">
<p>The implementation of the interface throws an <code>IOException</code> if the provided <code>Path</code> does not exist.</p>
</div>
<div class="paragraph">
<p><em>DefaultFileReader.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class DefaultFileReader implements FileReader {
    @Override
    public String readContent(Path path) throws IOException {
        if (Files.notExists(path)) {
            throw new IOException(&#34;File does not exist&#34;);
        }

        return new String(Files.readAllBytes(path));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 3. Default file reader implementation</em></p>
</div>
<div class="paragraph">
<p>You will find that the class <code>FileManager</code> is referenced in some of the test cases described below. <code>FileManager</code> is just a wrapper around <code>FileReader</code> to demonstrate mocking capabilities. You can find the <a href="https://github.com/bmuschko/junit5-vs-spock-feature-comparison/blob/master/src/main/java/com/bmuschko/test/comparison/FileManager.java">code for the class</a> in the source code repository.</p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="test-execution">Test execution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let’s start with the most simplistic use case: marking test methods or the whole class for execution with the test framework.</p>
</div>
<div class="sect2">
<h3 id="_junit_5">JUnit 5</h3>
<div class="paragraph">
<p>In JUnit 5 you use the annotation <code>@Test</code> to indicate that a method should be executed as a test. JUnit 5 takes a different approach than JUnit 4. The annotation is only applicable to a method but not the class. The annotated test method must not be <code>private</code> or <code>static</code>. Test methods do not return a value.</p>
</div>
<div class="paragraph">
<p><em>SimpleTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.Test;

public class SimpleTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Test
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }

    @Test
    void canMultiply() {
        assertEquals(6, arithmeticOperation.multiply(2, 3));
    }

    @Test
    void canDivide() {
        assertEquals(3, arithmeticOperation.divide(6, 2));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 4. Using annotation to indicate test execution</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock">Spock</h3>
<div class="paragraph">
<p>To indicate that all methods of a class should be treated as test methods, you’ll need to extend from <code>Specification</code>. On the one hand, extending from a class requires less work on your end to turn all methods into test methods. On the other hand, it makes it harder to create a hierarchy of parent classes in case you want to formalize reusable fixtures through inheritance. <a href="#disabling-tests">Disabling test cases</a> allows you to be more selective.</p>
</div>
<div class="paragraph">
<p><em>SimpleTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import spock.lang.Specification

class SimpleTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    def canSubstract() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }

    def canMultiply() {
        expect:
        arithmeticOperation.multiply(2, 3) == 6
    }

    def canDivide() {
        expect:
        arithmeticOperation.divide(6, 2) == 3
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 5. Extending from abstract class Specification</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fixture-setup-teardown">Fixture set up and tear down</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many tests require fixtures to be set up before any of the test methods can run successfully. A fixture can lay out the expected environment, establish a required class composition or ensure that a service can be reached. Fixtures can be costly to create e.g. if a service endpoint needs to be spun up. After the test method finishes, the fixture may need to be cleaned up.</p>
</div>
<div class="paragraph">
<p>JUnit 5 and Spock provide ways to create fixtures before individual test methods or just once per test class execution. Equivalent hooks are available for cleanup functionality.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_2">JUnit 5</h3>
<div class="paragraph">
<p>JUnit 5 supports fixture setup and teardown through annotations. The annotated methods for those operations can use any arbitrary name. You can chose from the following annotations: <code>@BeforeEach</code>, <code>@BeforeAll</code>, <code>@AfterEach</code> and <code>@AfterAll</code>. Please refer to the user guide for more information on <a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">those annotations</a>.</p>
</div>
<div class="paragraph">
<p>Using annotations to indicate fixture setup and teardown feels quite natural. The following test class demonstrates the application of <code>@BeforeEach</code> and <code>@AfterEach</code> to create and delete a temporary file so that the code under test can read its contents.</p>
</div>
<div class="paragraph">
<p><em>FixtureSetupCleanup.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;

public class FixtureSetupCleanup {
    private final FileReader fileReader = new DefaultFileReader();
    private Path testFile;

    @BeforeEach
    void setup() throws IOException {
        testFile = Files.createTempFile(&#34;junit5&#34;, &#34;.tmp&#34;);
    }

    @AfterEach
    void cleanup() {
        testFile.toFile().delete();
    }

    @Test
    void canReadFile() throws IOException {
        String text = &#34;hello&#34;;
        Files.write(testFile, text.getBytes());
        assertEquals(text, fileReader.readContent(testFile));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 6. Using annotations for setting up and tearing down fixtures</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_2">Spock</h3>
<div class="paragraph">
<p>Spock does not provide annotations to indicate fixture setup and teardown. If a test class implements the methods <code>setup()</code>, <code>setupSpec()</code>, <code>cleanup()</code>, and <code>cleanupSpec()</code> then Spock will automatically use the method body to handle fixtures. You can find more information about those methods in the <a href="http://spockframework.org/spock/docs/1.1/spock_primer.html">documentation</a>.</p>
</div>
<div class="paragraph">
<p><em>FixtureSetupCleanup.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class FixtureSetupCleanup extends Specification {
    @Subject def fileReader = new DefaultFileReader()
    def testFile

    def setup() {
        testFile = Files.createTempFile(&#34;junit5&#34;, &#34;.tmp&#34;)
    }

    def cleanup() {
        testFile.toFile().delete()
    }

    def &#34;can read file&#34;() {
        given:
        def text = &#34;hello&#34;
        testFile &lt;&lt; text

        when:
        def content = fileReader.readContent(testFile)

        then:
        content == text
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 7. Fixture methods in Spock</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="descriptive-test-names">Descriptive test names</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Test cases should clearly indicate its intent. A camel cased method name proves to be a weak concept to describe its coverage. JUnit 5 and Spock support provide better ways to make test cases human-readable.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_3">JUnit 5</h3>
<div class="paragraph">
<p>In JUnit 4, you could only rely on the method name to identify the test case. JUnit 5 introduces the annotation <code>@DisplayName</code> that allows users to provide a description of its intent. Check out the <a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names">user guide</a> for more information on display names.</p>
</div>
<div class="paragraph">
<p><em>DescriptiveTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.DisplayName;

public class DescriptiveTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    @DisplayName(&#34;can add two numbers&#34;)
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Test
    @DisplayName(&#34;can substract a number from another one&#34;)
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }

    @Test
    @DisplayName(&#34;can multiple two numbers&#34;)
    void canMultiply() {
        assertEquals(6, arithmeticOperation.multiply(2, 3));
    }

    @Test
    @DisplayName(&#34;can divide two numbers&#34;)
    void canDivide() {
        assertEquals(3, arithmeticOperation.divide(6, 2));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 8. Providing a descriptive test name by annotation</em></p>
</div>
<div class="paragraph">
<p>The executing environment takes the test description into account and uses it instead of the method name. The following screenshot shows the test execution in IntelliJ.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/blog/junit5-vs-spock-showdown/descriptive-names-junit5.png" alt="descriptive names junit5"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 1. Descriptive test names in IntelliJ</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_3">Spock</h3>
<div class="paragraph">
<p>Spock does not introduce an annotation to support descriptive test names. Instead it simply uses a Groovy language feature to do the heavy lifting. In Groovy, you can provide any String as method name.</p>
</div>
<div class="paragraph">
<p><em>DescriptiveTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class DescriptiveTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def &#34;can add two numbers&#34;() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    def &#34;can substract a number from another one&#34;() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }

    def &#34;can multiple two numbers&#34;() {
        expect:
        arithmeticOperation.multiply(2, 3) == 6
    }

    def &#34;can divide two numbers&#34;() {
        expect:
        arithmeticOperation.divide(6, 2) == 3
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 9. Using a String to provide a readable test description</em></p>
</div>
<div class="paragraph">
<p>The runtime environment properly evaluates the provided String as method name. The following screenshot shows how IntelliJ renders the executed Spock test cases.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/blog/junit5-vs-spock-showdown/descriptive-names-spock.png" alt="descriptive names spock"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 2. Descriptive test names in IntelliJ</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="disabling-tests">Disabling tests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Under certain conditions, you might want to disable single test methods. That’s typically the case if a test is failing temporarily or if a test covers functionality that hasn’t been implemented yet.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_4">JUnit 5</h3>
<div class="paragraph">
<p>JUnit 5 provides the annotation <code>@Disabled</code> to either disable all tests in a test class or individual test methods. A user can provide an optional reason to explain why the test was disabled. The following example demonstrates how to disable the test case <code>canAdd()</code>. More details can be found in the <a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-disabling">user guide</a>.</p>
</div>
<div class="paragraph">
<p><em>IgnoredTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.Disabled;

public class IgnoredTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    @Disabled(&#34;for demonstration purposes&#34;)
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 10. Disabling test methods by annotation</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_4">Spock</h3>
<div class="paragraph">
<p>Disabling a test in Spock follows the same pattern as JUnit 5. The API introduces the annotation <code>@Ignore</code>. The annotation can apply to a type or a method and allows for providing an optional reason. Groovy-based tests can also use the annotation <a href="http://docs.groovy-lang.org/latest/html/api/groovy/transform/NotYetImplemented.html"><code>@NotYetImplemented</code></a> to pass a test if a test failure occurs for functionality that currently does not work but will be implemented in the future.</p>
</div>
<div class="paragraph">
<p><em>IgnoredTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import spock.lang.Ignore

class IgnoredTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Ignore(&#34;for demonstration purposes&#34;)
    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 11. Using the Ignore annotation to disable a method</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expecting-thrown-exceptions">Expecting thrown exceptions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Methods can throw an exception. Being a good citizen you’ll want to test those cases as well to verify that the &#34;sad path&#34; behaves as expected.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_5">JUnit 5</h3>
<div class="paragraph">
<p>The JUnit 5 API provides fine-grained assertion methods for testing thrown exceptions. Any portions of code can be wrapped with the method <code>assertThrows</code>. The test will fail if the wrapped code block does not throw the expected exception. The <a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">user guide</a> provides an even more elaborate sample than the one below.</p>
</div>
<div class="paragraph">
<p><em>ExpectedExceptionTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import static org.junit.jupiter.api.Assertions.assertThrows;

public class ExpectedExceptionTest {
    private final FileReader fileReader = new DefaultFileReader();

    @Test
    void cannotReadNonExistentFile() {
        assertThrows(IOException.class, () -&gt; {
            fileReader.readContent(Paths.get(&#34;hello.text&#34;));
        });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 12. Asserting that a code block throws an expected exception</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_5">Spock</h3>
<div class="paragraph">
<p>In Spock-based tests a class or method can be annotated with <code>@FailsWith</code> to signal that a declared exception should be thrown. If you want more fine-grained control over which portion of the code should throw the exception then you’ll have to implement a <code>try</code>/<code>catch</code> block and assert the exception type.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can also use the method <code>thrown(Class)</code> to assert a thrown exception. The return value of the method grants access to the exception for further inspection.</p>
</div>
<div class="paragraph">
<p><em>ExpectedExceptionTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import spock.lang.FailsWith

class ExpectedExceptionTest extends Specification {
    @Subject def fileReader = new DefaultFileReader()

    @FailsWith(IOException)
    def &#34;throws exception if file contents cannot be read&#34;() {
        expect:
        fileReader.readContent(Paths.get(&#39;hello.text&#39;))
    }

    def &#34;throws exception if file contents cannot be read and assert message&#34;() {
        when:
        fileReader.readContent(Paths.get(&#39;hello.text&#39;))

        then:
        def t = thrown(IOException)
        t.message == &#39;File does not exist&#39;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 13. Declaring an expected exception by annotation</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repeating-test-execution">Repeating test execution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes you’ll want to verify that exercising the same logic multiples times leads to the coequal result. There are various examples that come to mind that require repeating a test:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Verifying that functionality is idempotent</p>
</li>
<li>
<p>Ensuring that a service endpoint can handle subsequent requests</p>
</li>
<li>
<p>Caching of data works as expected</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_junit_5_6">JUnit 5</h3>
<div class="paragraph">
<p>Test cases can be executed multiple times in a row by marking them with the <code>@RepeatedTest</code> annotation. Aside from declaring the number of repetitions you can also build a custom test name with the help of built-in variables. Check the <a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests">user guide</a> for more information.</p>
</div>
<div class="paragraph">
<p><em>RepetitionTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.RepeatedTest;

public class RepetitionTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @RepeatedTest(10)
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @RepeatedTest(value = 5, name = &#34;Iteration {currentRepetition} of {totalRepetitions}&#34;)
    void canSubstract() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 14. Repeating a test method by annotation</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_6">Spock</h3>
<div class="paragraph">
<p>Spock does not support test repetition out-of-the-box. You will need to roll your own mechanism. The following example code uses a <code>where</code> statement to repeat the test execution multiple times.</p>
</div>
<div class="paragraph">
<p><em>RepetitionTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class RepetitionTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Unroll
    def &#34;can add&#34;() {
        expect:
        arithmeticOperation.add(1, 2) == 3

        where:
        i &lt;&lt; (1..10)
    }

    @Unroll
    def &#34;Iteration #i of 5&#34;() {
        expect:
        arithmeticOperation.substract(2, 1) == 1

        where:
        i &lt;&lt; (1..5)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 15. Repeating a test method by counter</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="declaring-timeouts">Declaring test execution timeouts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Code under test may take a little time to finish. Operations can be very costly, calls across network boundaries can take a longer than expected due to latency, load tests should finish in an predefined amount of time. JUnit 5 and Spock provide adequate support for declaring test execution timeout. The test fails if it doesn’t finish within the expected time frame.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_7">JUnit 5</h3>
<div class="paragraph">
<p>A timeout in JUnit 5 is represented by the assertion method <code>assertTimeout</code>. Timeout declarations expect a <code>Duration</code> instance plus the code block that should finish in the expected timespan. You can learn more about the timeout assertion method in the <a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions">user guide</a>.</p>
</div>
<div class="paragraph">
<p><em>RepetitionTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import static java.time.Duration.ofSeconds;
import static org.junit.jupiter.api.Assertions.assertTimeout;

public class TimeoutTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertTimeout(ofSeconds(2), () -&gt; {
            assertEquals(3, arithmeticOperation.add(1, 2));
        });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 16. Fail a test if it doesn’t finish in expected timeout threshold</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_7">Spock</h3>
<div class="paragraph">
<p>Spock takes the route of providing an annotation to declare a test execution timeout. The annotation can be assigned to the whole test class or just individual test methods. By default the assigned value declares a timeout in seconds. You can provide a different <code>TimeUnit</code> if needed.</p>
</div>
<div class="paragraph">
<p><em>RepetitionTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import spock.lang.Timeout

class TimeoutTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Timeout(2)
    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 17. Convenient timeout definition by annotation</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conditional-test-execution">Conditional test execution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a large test suite you don’t necessarily want to execute all tests in every runtime environment. For example some tests should just run in a Windows environment but not on Linux. Or you might implement tests that should only run with a specific JDK version. Being able to control test execution proves to be extremely valuable if your test coverage becomes more complex or multifaceted.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_8">JUnit 5</h3>
<div class="paragraph">
<p>JUnit 5 offers the assertion method <code>assumeTrue</code>. If the expression evaluates to <code>true</code> then any code that follows will be executed. Should the expression validate to <code>false</code> then any test logic that follows is skipped. Internally, JUnit throws an exception that needs to be handled by the runtime environment.</p>
</div>
<div class="paragraph">
<p><em>ConditionalExecutionTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import static org.junit.jupiter.api.Assumptions.assumeTrue;

public class ConditionalExecutionTest {
    private final static String SYS_PROP_KEY = &#34;junit5.test.enabled&#34;;
    private final static String SYS_PROP_TRUE_VALUE = &#34;true&#34;;
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void testOnlyOnSystemSystemPropertySet() {
        assumeTrue(SYS_PROP_TRUE_VALUE.equals(System.getProperty(SYS_PROP_KEY)));
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 18. Conditional test execution using assumeTrue</em></p>
</div>
<div class="paragraph">
<p>IntelliJ properly handles conditional execution for JUnit 5. The console renders the message <code>org.opentest4j.TestAbortedException: Assumption failed: assumption is not true</code> for an expression that evaluates to <code>false</code> and records the method as skipped.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/blog/junit5-vs-spock-showdown/conditional-execution-junit5.png" alt="conditional execution junit5"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 3. IntelliJ handles a TestAbortedException thrown by JUnit 5</em></p>
</div>
<div class="paragraph">
<p>For capturing more complex expressions, the JUnit API also allows for writing an implementation of <a href="http://junit.org/junit5/docs/current/user-guide/#extensions-conditions"><code>ExecutionCondition</code></a>. The interface represents an extension to the test framework and can be applied on the class- and method-level. For more information about <a href="#extending-test-framework">extending the test framework</a>, see the section below.</p>
</div>
<div class="paragraph">
<p><em>ConditionalExecutionTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.extension.ConditionEvaluationResult;
import org.junit.jupiter.api.extension.ExecutionCondition;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.ExtensionContext;

import static org.junit.jupiter.api.extension.ConditionEvaluationResult.disabled;
import static org.junit.jupiter.api.extension.ConditionEvaluationResult.enabled;

public class ConditionalExecutionTest {
    ...

    @ExtendWith(SystemPropertyConditionalExtension.class)
    @Test
    void testOnlyOnSystemSystemPropertySetByExtension() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    private static class SystemPropertyConditionalExtension
        implements ExecutionCondition {
        @Override
        public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext
            context) {
            String sysPropValue = System.getProperty(SYS_PROP_KEY);
            boolean enabled = SYS_PROP_TRUE_VALUE.equals(sysPropValue);

            if (enabled) {
                return enabled(String.format(&#34;System property &#39;%s&#39; evaluates to true&#34;,
                    SYS_PROP_KEY));
            }

            return disabled(String.format(&#34;System property &#39;%s&#39; evaluates to false&#34;,
                SYS_PROP_KEY));
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 19. Conditional test execution using ExecutionCondition</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_8">Spock</h3>
<div class="paragraph">
<p>Spock really shines when it comes to conditional test execution. You can define the condition with the help of a closure return any arbitrary expression. The closure is assigned to either the annotation <code>@Requires</code> or <code>@IgnoreIf</code>. Overall Spock’s support for conditional test execution feels more flexible than JUnit’s capabilities. The following example shows the use of the <code>@Requires</code> annotation.</p>
</div>
<div class="paragraph">
<p><em>ConditionalExecutionTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import spock.lang.Requires

class ConditionalExecutionTest extends Specification {
    private final static String SYS_PROP_KEY = &#34;spock.test.enabled&#34;
    private final static String SYS_PROP_TRUE_VALUE = &#34;true&#34;
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Requires({ SYS_PROP_TRUE_VALUE == sys[SYS_PROP_KEY] })
    def &#34;can add&#34;() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 20. Expression-based test execution defined as annotation parameter</em></p>
</div>
<div class="paragraph">
<p>The following screenshot shows the handling in IntelliJ.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/blog/junit5-vs-spock-showdown/conditional-execution-spock.png" alt="conditional execution spock"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 4. Conditional test execution by annotation in IntelliJ</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-driven-tests">Data-driven tests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Production source code might behave differently at runtime if provided with varying inputs. Copy-pasting the same test case over and over again with different data sets leads to unmaintainable test classes. The better option is to run the same test case multiple times but with different inputs. Data-driven tests represent a feature I personally use in almost every project. I wouldn’t want to miss it.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_9">JUnit 5</h3>
<div class="paragraph">
<p>You have various options to feed data to a test case. First of all, you’ll need to mark the method with the annotation <code>@ParameterizedTest</code> to indicate that it receives data and should be executed multiple times. The annotation also allows for building a custom test description based on the parameter values.</p>
</div>
<div class="paragraph">
<p>One way to feed the data is with the help of the annotation <code>@ValueSource</code>. I don’t find this annotation very helpful as it can only provide a flat list of single input values. To make the functionality useful you’ll most likely also need to provide a second or third input value, a corresponding result value and potentially a textual description that represents the test case. The annotation <code>@MethodSource</code> can refer to a method returning a more complex matrix combination of values. Unfortunately, there’s no way to provide an identifier to any of the values making it hard to parse and understand.</p>
</div>
<div class="paragraph">
<p><em>DataDrivenTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.stream.Stream;

public class DataDrivenTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @ParameterizedTest
    @ValueSource(ints = { 1, 2, 3, 4, 5 })
    void canAdd(int b) {
        assertTrue(arithmeticOperation.add(1, b) &gt;= 2);
    }

    @ParameterizedTest(name = &#34;can add {0} to {1} and receive {2}&#34;)
    @MethodSource(&#34;additionProvider&#34;)
    void canAddAndAssertExactResult(int a, int b, int result) {
        assertEquals(result, arithmeticOperation.add(a, b));
    }

    static Stream&lt;Arguments&gt; additionProvider() {
        return Stream.of(
            Arguments.of(1, 3, 4),
            Arguments.of(3, 4, 7),
            Arguments.of(10, 20, 30)
        );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 21. Declaring a value source and provider to provide data to test</em></p>
</div>
<div class="paragraph">
<p>IntelliJ groups data-driven execution per test method. The result is very readable. Furthermore, the IDE also renders the type for each input value in parathesis next to the test name.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/blog/junit5-vs-spock-showdown/data-driven-test-junit5.png" alt="data driven test junit5"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 5. JUnit 5 data-driven test execution in IntelliJ</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_9">Spock</h3>
<div class="paragraph">
<p>Spock solves <a href="http://spockframework.org/spock/docs/1.1/data_driven_testing.html">data-driven tests</a> in a very elegant and pragmatic way. The data is provided as a table with descriptive headers in a <code>where</code> clause. Each row in the data table represents a single execution of the test. Each named identifier can be referenced in the method name via the pound character (<code>#</code>) to build a meaningful test case description. The <code>@Unroll</code> annotation tells Spock to treat each test execution as individual test case. From my perspective data-driven tests are <em>the</em> Spock killer feature.</p>
</div>
<div class="paragraph">
<p><em>DataDrivenTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import spock.lang.Unroll

class DataDrivenTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Unroll
    def &#34;can add&#34;() {
        expect:
        arithmeticOperation.add(1, b) &gt;= 2

        where:
        b &lt;&lt; [1, 2, 3, 4, 5]
    }

    @Unroll
    def &#34;can add #a to #b and receive #result&#34;() {
        expect:
        arithmeticOperation.add(a, b) == result

        where:
        a  | b  | result
        1  | 3  | 4
        3  | 4  | 7
        10 | 20 | 30
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 22. Providing data to test execution by table</em></p>
</div>
<div class="paragraph">
<p>For Spock-based tests IntelliJ only renders a flat list of test executions.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/img/blog/junit5-vs-spock-showdown/data-driven-test-spock.png" alt="data driven test spock"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 6. IntelliJ renders each data line for Spock-based tests</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mocking">Mocking</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Classes rarely work in isolation. Most classes call off to other class instances, services or subsystems. <a href="https://en.wikipedia.org/wiki/Mock_object">Mocking</a> enabled you to cut off any integration point, replace it by a stand-in object and make it respond as needed for the test case.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_10">JUnit 5</h3>
<div class="paragraph">
<p>JUnit 5 does not ship with any mocking capabilities. Many users resort to the popular mocking library <a href="http://site.mockito.org/">Mockito</a>. The following example demonstrates the use of Mockito as part of a test case. The Mockito API calls nicely blend into the logic of the test case. Beginners to testing might have a hard time to visually separate test code from mocking expectations.</p>
</div>
<div class="paragraph">
<p><em>MockTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class MockTest {
    private Path testFile;

    @BeforeEach
    void setup() throws IOException {
        testFile = Files.createTempFile(&#34;junit5&#34;, &#34;.tmp&#34;);
    }

    @AfterEach
    void cleanup() {
        testFile.toFile().delete();
    }

    @Test
    void canMockFileReadOperation() throws IOException {
        String text = &#34;hello&#34;;
        FileReader fileReader = mock(FileReader.class);
        when(fileReader.readContent(testFile)).thenReturn(text);
        FileManager fileManager = new DefaultFileManager(fileReader);
        Files.write(testFile, text.getBytes());
        assertEquals(text, fileManager.readContent(testFile));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 23. Using Mockito to inject mock instance</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_10">Spock</h3>
<div class="paragraph">
<p>Mocks and stubs are an integrated part of the Spock API. You do not have to pull in yet another external dependency to fulfill all testing needs. Creating mock objects and defining expected interactions in Spock is straightforward. You can learn more about Spock’s <a href="http://spockframework.org/spock/docs/1.1/interaction_based_testing.html">interaction based testing</a> in the user guide.</p>
</div>
<div class="paragraph">
<p><em>MockTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class MockTest extends Specification {
    def fileReader = Mock(FileReader)
    @Subject def fileManager = new DefaultFileManager(fileReader)
    def testFile

    void setup() {
        testFile = Files.createTempFile(&#34;junit5&#34;, &#34;.tmp&#34;)
    }

    void cleanup() {
        testFile.toFile().delete()
    }

    def &#34;can mock file read operation&#34;() {
        given:
        def text = &#34;hello&#34;
        Files.write(testFile, text.getBytes())

        when:
        def content = fileManager.readContent(testFile)

        then:
        1 * fileReader.readContent(testFile) &gt;&gt; text
        content == text
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 24. Built-in mock capabilities</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="labeling-filtering">Labeling and filtering test execution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Grouping and executing tests based on functional boundaries becomes inevitable with a growing amount of coverage. For example you might want to split slow- from fast-running tests, unit from integration tests or set up a test suite for load testing. Both test frameworks provide sufficient tooling for labeling tests and running them in dedicated runs.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_11">JUnit 5</h3>
<div class="paragraph">
<p>In JUnit you can label tests with so-called <a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering">tags</a>. To tag a test class or method use the <code>@Tag</code> annotation and provide a short description as String. The example below separates slow- from fast-running tests.</p>
</div>
<div class="paragraph">
<p><em>TaggedTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.Tag;

public class TaggedTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Tag(&#34;slow&#34;)
    @Test
    void runsSlowly() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }

    @Tag(&#34;fast&#34;)
    @Test
    void runsFast() {
        assertEquals(1, arithmeticOperation.substract(2, 1));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 25. Tagged test methods</em></p>
</div>
<div class="paragraph">
<p>The description of a tagged test can serve as documentation for other developers. However, only in combination with test filtering, tagging becomes really beneficial. The following example sets up a test suite for running &#34;fast&#34; tests. Filtering tests requires the dependency <a href="http://junit.org/junit5/docs/current/user-guide/#dependency-metadata-junit-platform"><code>org.junit.platform:junit-platform-runner</code></a> to be available on the test compilation classpath.</p>
</div>
<div class="paragraph">
<p><em>FilteredFastTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.platform.runner.JUnitPlatform;
import org.junit.platform.suite.api.IncludeTags;
import org.junit.platform.suite.api.SelectPackages;
import org.junit.runner.RunWith;

@RunWith(JUnitPlatform.class)
@SelectPackages(&#34;com.bmuschko.test.comparison.junit5.tagged&#34;)
@IncludeTags(&#34;fast&#34;)
public class FilteredFastTest {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 26. Test suite executing fast tests</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_11">Spock</h3>
<div class="paragraph">
<p>The Spock API does not define the concept of a tag. Nevertheless, it’s very easy to set up labeling yourself. The following two annotation classes serve the purpose of suggesting slow- and fast-running tests.</p>
</div>
<div class="paragraph">
<p><em>Slow.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
@interface Slow {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 27. Interface annotation indicating slow-running tests</em></p>
</div>
<div class="paragraph">
<p><em>Fast.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
@interface Fast {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 28. Interface annotation indicating fast-running tests</em></p>
</div>
<div class="paragraph">
<p>Labeling test case methods with the annotations is straightforward. The example below uses both custom annotations.</p>
</div>
<div class="paragraph">
<p><em>TaggedTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class TaggedTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    @Slow
    def &#34;runs slowly&#34;() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }

    @Fast
    def &#34;runs fast&#34;() {
        expect:
        arithmeticOperation.substract(2, 1) == 1
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 29. Annotated test methods</em></p>
</div>
<div class="paragraph">
<p>Labeled test cases can be filtered with the help of a Spock configuration file. Spock searches for a file with the name <code>SpockConfig.groovy</code> on the classpath. The configuration file can tell the test runner which test suite to execute.</p>
</div>
<div class="paragraph">
<p><em>SpockConfig.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import com.bmuschko.test.comparison.spock.tagged.Fast

runner {
    include Fast
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 30. Spock runner configuration to filter annotated tests</em></p>
</div>
<div class="paragraph">
<p>The approach is less convenient than the one provided by JUnit 5 especially if you have to deal with more than one test suite. Please be aware that you can also provide the configuration to the test JVM with the system property <code>spock.configuration</code>.</p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extending-test-framework">Extending the test framework</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JUnit 5 and Spock are powerful tools with a lot of built-in functionality. Nevertheless, a test framework cannot anticipate all requirements a real world project might have. You can enhance the base functionality with an extension in case you need custom logic that ties into the existing API. This blog post won’t go very deep into the available options for each test framework. I’d highly encourage you to explore the API for yourself.</p>
</div>
<div class="paragraph">
<p>The simple example below demonstrates basic extension capabilities. The implementation reacts to lifecycle events emitted before and after executing a test case. Each event logs the name of test method to the standard output stream.</p>
</div>
<div class="sect2">
<h3 id="_junit_5_12">JUnit 5</h3>
<div class="paragraph">
<p>The test framework’s <a href="http://junit.org/junit5/docs/current/user-guide/#extensions">extension model</a> provides callback interfaces to react to prominent lifecycle events. As you can see in listing 31, the extension class implements the interfaces <code>BeforeTestExecutionCallback</code> and <code>AfterTestExecutionCallback</code>. The callback interfaces provide a context object of type <code>ExtensionContext</code> giving you access to detailed information about the executed test method.</p>
</div>
<div class="paragraph">
<p><em>BeforeAfterLoggingExtension.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
import org.junit.jupiter.api.extension.BeforeTestExecutionCallback;
import org.junit.jupiter.api.extension.ExtensionContext;

public class BeforeAfterLoggingExtension implements BeforeTestExecutionCallback, AfterTestExecutionCallback {
    @Override
    public void beforeTestExecution(ExtensionContext context) {
        Method testMethod = context.getRequiredTestMethod();
        System.out.println(String.format(&#34;Starting test method %s.%s&#34;, testMethod.getDeclaringClass(), testMethod.getName()));
    }

    @Override
    public void afterTestExecution(ExtensionContext context) {
        Method testMethod = context.getRequiredTestMethod();
        System.out.println(String.format(&#34;Finishing test method %s.%s&#34;, testMethod.getDeclaringClass(), testMethod.getName()));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 31. Test execution callback handler</em></p>
</div>
<div class="paragraph">
<p>Extensions can be applied to test classes or methods with the help of the annotation <code>@ExtendWith</code>. That’s it! You implemented your first extension.</p>
</div>
<div class="paragraph">
<p><em>LoggingTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(BeforeAfterLoggingExtension.class)
public class LoggingTest {
    private final ArithmeticOperation arithmeticOperation = new ArithmeticOperation();

    @Test
    void canAdd() {
        assertEquals(3, arithmeticOperation.add(1, 2));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 32. Using extension in test class</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_spock_12">Spock</h3>
<div class="paragraph">
<p>Spock takes a <a href="http://spockframework.org/spock/docs/1.1/extensions.html">similar approach</a> as JUnit 5. You need to implement the listener interface <code>IRunListener</code> to intercept test lifecycle events. Thankfully, the API already provides a stub implementation <code>AbstractRunListener</code> so you only have to implement the event methods you are interested in.</p>
</div>
<div class="paragraph">
<p><em>BeforeAfterEventListener.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import org.spockframework.runtime.AbstractRunListener
import org.spockframework.runtime.model.FeatureInfo

class BeforeAfterEventListener extends AbstractRunListener {
    @Override
    void beforeFeature(FeatureInfo feature) {
        println &#34;Starting test method ${feature.description.className}.${feature.description.methodName}&#34;
    }

    @Override
    void afterFeature(FeatureInfo feature) {
        println &#34;Finishing test method ${feature.description.className}.${feature.description.methodName}&#34;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 33. Event listener implementation in Spock</em></p>
</div>
<div class="paragraph">
<p>In our example, the extension should only be available for the test class. Listing 34 implements an annotation class for that very purpose.</p>
</div>
<div class="paragraph">
<p><em>BeforeAfterLogging.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import org.spockframework.runtime.extension.ExtensionAnnotation

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@ExtensionAnnotation(BeforeAfterLoggingExtension.class)
@interface BeforeAfterLogging {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 34. Exposing an annotation evaluated by extension</em></p>
</div>
<div class="paragraph">
<p>With the listener and the annotation in place, you can now create a new extension implementation. Spock provides a convenient abstract implementation named <code>AbstractAnnotationDrivenExtension</code> for registering the listener.</p>
</div>
<div class="paragraph">
<p><em>BeforeAfterLoggingExtension.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import org.spockframework.runtime.extension.AbstractAnnotationDrivenExtension
import org.spockframework.runtime.model.SpecInfo

class BeforeAfterLoggingExtension extends AbstractAnnotationDrivenExtension&lt;BeforeAfterLogging&gt; {
    @Override
    void visitSpecAnnotation(BeforeAfterLogging annotation, SpecInfo spec) {
        spec.addListener(new BeforeAfterEventListener())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 35. Registering the listener by extension</em></p>
</div>
<div class="paragraph">
<p>Any test class can use the annotation to automatically apply the logic implemented by the extension.</p>
</div>
<div class="paragraph">
<p><em>LoggingTest.groovy</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@BeforeAfterLogging
class LoggingTest extends Specification {
    @Subject def arithmeticOperation = new ArithmeticOperation()

    def canAdd() {
        expect:
        arithmeticOperation.add(1, 2) == 3
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 36. Using the logging extension in a test class</em></p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JUnit has come a long way since version 4. Not only does version 5 present an attractive feature set it also revolutionizes the underlying runtime platform. Almost all features available in Spock have an equivalent in JUnit 5 making it enterprise-ready tooling.</p>
</div>
<div class="paragraph">
<p>Given JUnit’s popularity I am confident that many organizations will adopt the latest version of the test framework while at the same time keeping legacy, JUnit 4-based tests runnable through the <a href="http://junit.org/junit5/docs/current/user-guide/#dependency-metadata-junit-vintage">Jupiter Vintage test engine</a>.</p>
</div>
<div class="paragraph">
<p>Personally, I like the BDD-style of Spock tests better. Test cases are more readable, self-explantory and just a pleasure to write. <a href="#data-driven-tests">Data-driven tests</a> and <a href="#conditional-test-execution">conditional test execution</a> are features I use on a daily basis and hope JUnit 5 will catch up on them in a future version.</p>
</div>
</div>
</div>

              <hr>
              <div class="related-posts">
                <h5>Related Posts</h5>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        November 25, 2018
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/asciidoctorj-extension/">Writing, testing and publishing an AsciidoctorJ extension</a></strong>
                      </h6>
                    </div>
                  </div>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        November 12, 2018
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/java-project-testcontainers/">Testing a Java project with TestContainers on JUnit 5</a></strong>
                      </h6>
                    </div>
                  </div>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        June 13, 2018
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/go-testing-frameworks/">Exploring the landscape of Go testing frameworks</a></strong>
                      </h6>
                    </div>
                  </div>
                
              </div>
            </div>
          </div>
          <hr>
        <div class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">

    (function() {
      
      
      if (window.location.hostname == "localhost")
        return;

      var disqus_shortname = 'bmuschko-com';
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
        </div>
      </div>
    </div>

    
    <footer>
  <div id="footer">
    <div class="container">
      <p class="text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io/">Hugo</a> and
      <a href="http://www.github.com/nurlansu/hugo-sustain/">sustain</a> with ♥</p>
    </div>
  </div>
</footer>
<div class="footer"></div>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://bmuschko.com/js/docs.min.js"></script>
<script src="https://bmuschko.com/js/main.js"></script>

<script src="https://bmuschko.com/js/ie10-viewport-bug-workaround.js"></script><!-- Syntax highlighting -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/shell.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/groovy.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



    
  </body>
</html>
