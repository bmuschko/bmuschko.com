<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="map[]" />
    
    <link rel="shortcut icon" type="image/x-icon" href="https://bmuschko.com/img/favicon.ico">
    <title>Writing, testing and publishing an AsciidoctorJ extension</title>
    <meta name="generator" content="Hugo 0.84.0" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://bmuschko.com/css/main.css" /><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/darcula.min.css">
    
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,200bold,400old" />
    
    <!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->

    
        
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-99678333-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
    
  </head>

  <body>
    <div id="wrap">

      
      <nav class="navbar navbar-default">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://bmuschko.com/"><i class="fa fa-home"></i></a>
    </div>
    <div id="navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
        <li><a href="/blog/">BLOG</a></li>
        
        <li><a href="/talks/">TALKS</a></li>
        
      
      </ul>
    </div>
  </div>
</nav>

      <div class="container">
        <div class="blog-post">
          <h3>
            <strong><a href="https://bmuschko.com/blog/asciidoctorj-extension/">Writing, testing and publishing an AsciidoctorJ extension</a></strong>
          </h3>
        </div>
        <div class="blog-title">
          <h4>
            
            <span class="label label-success">documentation</span>
            
            <span class="label label-success">asciidoc</span>
            
            <span class="label label-success">asciidoctor</span>
            
            <span class="label label-success">extension</span>
            
            <span class="label label-success">testing</span>
            
            </br></br></br>
            November 25, 2018
          </h4>
        </div>
        <div class="panel panel-default">
          <div class="panel-body">
            <div class="blogpost">
              <div class="paragraph">
<p><a href="http://asciidoc.org/">Asciidoc</a> is a powerful markup language and extensible platform for producing documentation. Sometimes the requirements for producing documentation go beyond its built-in capabilities. Asciidoc enabled content producers to enhance the basic functionality of the platform by writing so-called extensions - think plugin for Asciidoc.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/asciidoctor/asciidoctorj">AsciidoctorJ</a> is the library for running Asciidoctor on the JVM. It comes into play when converting Asciidoc content to the target format (e.g. HTML) from Java. This library also serves as the basis for writing extensions.</p>
</div>
<div class="paragraph">
<p>In this blog post, I want to explain how to write, test, publish and use an AsciidoctorJ extension. As an example, we’ll implement functionality for rendering code blocks on multiple tabs. Tabbed code blocks are particularly useful if you want to demonstrate a code example in different languages or tool syntax. Figure 1 shows a tabbed code block in action.</p>
</div>
<div class="paragraph">
<p><span class="image left"><img src="/img/blog/asciidoctorj-extension/tabbed-code-groovy.png" alt="tabbed code groovy" width="360"/></span>
<span class="image right"><img src="/img/blog/asciidoctorj-extension/tabbed-code-kotlin.png" alt="tabbed code kotlin" width="360"/></span></p>
</div>
<div class="paragraph">
<p><em>Figure 1. The AsciidoctorJ extension for renderings tabbed code blocks in action</em></p>
</div>
<div class="paragraph">
<p>In the figure, you can see the effect of using such an extension in a generated HTML output format. The tabs show a code example for the languages Groovy and Kotlin, each with their own syntax. The user can click one of the tabs to activate the relevant code example. An active tab is highlighted in a specific color.</p>
</div>
<div class="paragraph">
<p>Let’s dive in and see how to implement this AsciidoctorJ extension. For reference, see the <a href="https://github.com/bmuschko/asciidoctorj-tabbed-code-extension">complete source code</a> in on GitHub.</p>
</div>
<hr/>
<div class="sect1">
<h2 id="_implementing_the_extension">Implementing the extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The AsciidoctorJ API exposes a set of <a href="https://asciidoctor.org/docs/asciidoctorj/#extension-api">extension points</a>. An extension point can manipulate the generated result of an Asciidoc document. For example, an implementation of the <a href="https://asciidoctor.org/docs/asciidoctorj/#postprocessor"><code>Postprocessor</code></a> inserts custom footer text.</p>
</div>
<div class="paragraph">
<p>A tabbed code block requires the insertion of dynamic behavior and custom styling. For this purpose, we’ll need to add CSS and JavaScript to the <code>&lt;head&gt;</code> tag of a generated HTML document. The <a href="https://asciidoctor.org/docs/asciidoctorj/#docinfoprocessor"><code>DocinfoProcessor</code></a> extension point can directly manipulate the header and footer of a document and is a good fit for our use case.</p>
</div>
<div class="paragraph">
<p>Listing 1 shows a class that implements the abstract class <code>DocinfoProcessor</code>. The code example omits elaborate implementation details e.g. how to read a file from the classpath. For more details, have a look at the <a href="https://github.com/bmuschko/asciidoctorj-tabbed-code-extension/blob/master/src/main/java/com/bmuschko/asciidoctorj/tabbedcode/TabbedCodeBlockDocinfoProcessor.java">full source code of the class</a>.</p>
</div>
<div class="paragraph">
<p><em>TabbedCodeBlockDocinfoProcessor.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.asciidoctor.ast.Document;
import org.asciidoctor.extension.DocinfoProcessor;

import java.util.Map;

public class TabbedCodeBlockDocinfoProcessor extends DocinfoProcessor {
    public static final String TABBED_CODE_CSS_FILE_PATH_ATTRIBUTE = &#34;tabbed-code-css-path&#34;;
    public static final String TABBED_CODE_JS_FILE_PATH_ATTRIBUTE = &#34;tabbed-code-js-path&#34;;
    public static final String DEFAULT_CSS_FILE_PATH = &#34;/codeBlockSwitch.css&#34;;
    public static final String DEFAULT_JS_FILE_PATH = &#34;/codeBlockSwitch.js&#34;;

    @Override
    public String process(Document document) {
        if (document.isBasebackend(&#34;html&#34;)) {
            Map&lt;String, Object&gt; attributes = document.getAttributes();
            String cssPath = getCssPath(attributes, TABBED_CODE_CSS_FILE_PATH_ATTRIBUTE, DEFAULT_CSS_FILE_PATH);
            String jsPath = getCssPath(attributes, TABBED_CODE_JS_FILE_PATH_ATTRIBUTE, DEFAULT_JS_FILE_PATH);
            String css = readFileContentsFromClasspath(cssPath);
            String js = readFileContentsFromClasspath(jsPath);
            return modifyHeadHtml(css, js);
        }

        return null;
    }

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 1. An implementation of DocinfoProcessor</em></p>
</div>
<div class="paragraph">
<p>I’d like to point out two notable pieces in this code example. You might have noticed that the <code>process</code> method only handles HTML processing. We do this for a simple reason. Adding a tabbed code block to other backends like PDF files would require different handling. By default the class uses a predefined CSS and JavaScript file that ships with the distribution of the extension. Alternatively, the end user can also set an <a href="https://asciidoctor.org/docs/asciidoctorj/#conversion-options">attribute</a> for providing custom styling or JavaScript behavior.</p>
</div>
<div class="paragraph">
<p>Every extension you’d like to make available to the Asciidoctor processor needs to be registered. You do this by implementing a class of type <code>ExtensionRegistry</code>. Listing 2 demonstrates an implementation that adds the <code>TabbedCodeBlockDocinfoProcessor</code> to the extension registry.</p>
</div>
<div class="paragraph">
<p><em>TabbedCodeBlockExtension.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.asciidoctor.Asciidoctor;
import org.asciidoctor.extension.JavaExtensionRegistry;
import org.asciidoctor.extension.spi.ExtensionRegistry;

public class TabbedCodeBlockExtension implements ExtensionRegistry {
    @Override
    public void register(Asciidoctor asciidoctor) {
        JavaExtensionRegistry javaExtensionRegistry = asciidoctor.javaExtensionRegistry();
        javaExtensionRegistry.docinfoProcessor(TabbedCodeBlockDocinfoProcessor.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 2. Registering the DocinfoProcessor with the extension registry</em></p>
</div>
<div class="paragraph">
<p>We are not done yet. You also need to create a file named <code>org.asciidoctor.extension.spi.ExtensionRegistry</code> and point it to the extension implementation so that Asciidoctor can discover it.</p>
</div>
<div class="paragraph">
<p><em>META-INF/services/org.asciidoctor.extension.spi.ExtensionRegistry</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">com.bmuschko.asciidoctorj.tabbedcode.TabbedCodeBlockExtension</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 3. Making the extension discoverable</em></p>
</div>
<div class="paragraph">
<p>Voilà, you wrote your first AsciidoctorJ extension. Next, we’ll concentrate on the important aspects of testing, publishing and the usage of the extension.</p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_testing_the_extension">Testing the extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before bundling the extension into a JAR file, we should make sure that the code is tested. Testing an extension is very similar to writing an extension. You can create an instance of <code>Asciidoctor</code> to emulate the processing of an Asciidoc document. To register an extension under test, simply add it to the registry programmatically as with did in <code>TabbedCodeBlockExtension</code>.</p>
</div>
<div class="paragraph">
<p>It’s worth mentioning that the <code>Asciidoctor</code> instance doesn’t fully behave like the runtime instance you’d usually deal with in a production environment. You’ll have to change the <code>SafeMode</code> and tell the processor which portions of the generated document to produce. In listing 4, we run the the Asciidoc processing in server mode and ensure that we receive the header and footer for later verification in the test case.</p>
</div>
<div class="paragraph">
<p><em>TabbedCodeBlockDocinfoProcessorTest.java</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.asciidoctor.Asciidoctor;
import org.asciidoctor.OptionsBuilder;
import org.asciidoctor.SafeMode;

public class TabbedCodeBlockDocinfoProcessorTest {
    @Test
    @DisplayName(&#34;can create HTML tabbed code block with default settings&#34;)
    void canCreateHtmlTabbedCodeBlockWithDefaultsSettings() {
        String result = convert(createOptionBuilder());
        verifyConvertedHtml(result, DEFAULT_CSS_FILE_PATH, DEFAULT_JS_FILE_PATH);
    }

    private static String convert(OptionsBuilder optionsBuilder) {
        Asciidoctor asciidoctor = Asciidoctor.Factory.create();
        asciidoctor.javaExtensionRegistry().docinfoProcessor(TabbedCodeBlockDocinfoProcessor.class);
        return asciidoctor.convert(getAsciiDoc(), optionsBuilder);
    }

    private static OptionsBuilder createOptionBuilder() {
        return OptionsBuilder.options().headerFooter(true).safe(SafeMode.SERVER);
    }

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 4. Writing tests to verifying the correct extension behavior</em></p>
</div>
<div class="paragraph">
<p>The code above only shows one test case. For a full breath of test cases, refer to the <a href="https://github.com/bmuschko/asciidoctorj-tabbed-code-extension/blob/master/src/test/java/com/bmuschko/asciidoctorj/tabbedcode/TabbedCodeBlockDocinfoProcessorTest.java">full implementation</a> of a JUnit 5 test class.</p>
</div>
<div class="paragraph">
<p>Next, we’ll look at publishing the extension.</p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_publishing_the_extension">Publishing the extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To make an extension reusable, you have to compile the source code, bundle it into a JAR file and then publish it to a binary repository. For the example extension, I decided to make it available on Bintray’s JCenter. JCenter is a superset of Maven Central so you should be able to retrieve from there as well.</p>
</div>
<div class="paragraph">
<p>AsciidoctorJ doesn’t provide any tooling for publishing extensions. I decided to go with Gradle for publishing to Bintray. I won’t go into details in this blog post but you can find the <a href="https://github.com/bmuschko/asciidoctorj-tabbed-code-extension/blob/master/buildSrc/src/main/kotlin/com/bmuschko/asciidoctorj/tabbedcode/PublishingPlugin.kt">relevant code</a> on GitHub.</p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_extension">Using the extension</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let’s assume we already published a version of the AsciidoctorJ extension. Now it’s time to use it. Optimally, you’d use a build tool to declare a dependency on the binary containing the AsciidoctorJ extension.</p>
</div>
<div class="sect2">
<h3 id="_declaring_the_dependency">Declaring the dependency</h3>
<div class="paragraph">
<p>A build tool helps you with automatically resolving a dependency and its transitive dependencies. Furthermore, it adds the dependency to the assigned classpath. AsciidoctorJ extensions are not needed during compilation. They only need to be available when processing Asciidoc files - at runtime. Therefore, we’ll have to declare the dependency with the appropriate scope/configuration.</p>
</div>
<div class="paragraph">
<p>To use the dependency from a Maven build, add the following dependency declaration. The scope should be <code>runtime</code>. Make sure to declare JCenter as one of the repositories in your Maven setup, as shown in listing 5.</p>
</div>
<div class="paragraph">
<p><em>pom.xml</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;jcenter&lt;/id&gt;
      &lt;url&gt;https://jcenter.bintray.com/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.bmuschko&lt;/groupId&gt;
    &lt;artifactId&gt;asciidoctorj-tabbed-code-extension&lt;/artifactId&gt;
    &lt;version&gt;0.2&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 5. Declaring the extension dependency in a Maven build</em></p>
</div>
<div class="paragraph">
<p>The build code for Gradle looks similar. First, we define JCenter as repository. Then we assign the AsciidoctorJ extension dependency to the <code>runtimeOnly</code> configuration.</p>
</div>
<div class="paragraph">
<p><em>build.gradle.kts</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>repositories {
    jcenter()
}

dependencies {
    runtimeOnly(&#34;com.bmuschko:asciidoctorj-tabbed-code-extension:0.2&#34;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 6. Declaring the extension dependency in a Gradle build</em></p>
</div>
<div class="paragraph">
<p>While talking about the build tool integration, let’s also have a brief look at customizing the extension’s runtime behavior.</p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_customizing_the_runtime_behavior">Customizing the runtime behavior</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You might not like the default look &amp; feel of the rendered tabs. The AsciidoctorJ extension can be configured to use a different CSS and JavaScript files. Attributes are the key mechanism for injecting runtime behavior. In listing 7, we point the attribute <code>tabbed-code-css-path</code> to the  custom CSS file available on the classpath of the project.</p>
</div>
<div class="paragraph">
<p><em>build.gradle.kts</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>tasks.named&lt;AsciidoctorTask&gt;(&#34;asciidoctor&#34;) {
    sourceDir = file(&#34;src/docs/asciidoc&#34;)
    sources(delegateClosureOf&lt;PatternSet&gt; {
        include(&#34;index.adoc&#34;)
    })

    attributes(
        mapOf(
            &#34;toc&#34; to &#34;left&#34;,
            &#34;source-highlighter&#34; to &#34;prettify&#34;,
            &#34;icons&#34; to &#34;font&#34;,
            &#34;numbered&#34; to &#34;&#34;,
            &#34;idprefix&#34; to &#34;&#34;,
            &#34;docinfo1&#34; to &#34;true&#34;,
            &#34;sectanchors&#34; to &#34;true&#34;,
            &#34;tabbed-code-css-path&#34; to &#34;/customTabbedCode.css&#34;
        )
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 7. Customizing the AsciidoctorJ extension in a Gradle build</em></p>
</div>
<div class="paragraph">
<p>What’s left in this discussion? Using the extension in an actual Asciidoc document. The last section of this blog post gives a quick overview.</p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_extension_in_an_asciidoc_document">Using the extension in an Asciidoc document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Rendering a tabbed code block with the extension in place is a piece of cake. Create different code blocks with the relevant label. Additionally, provide the source code type and a role. Done and done! The resulting tabbed code block should look like figure 1.</p>
</div>
<div class="paragraph">
<p><em>sample.adoc</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[source,groovy,indent=0,subs=&#34;verbatim,attributes&#34;,role=&#34;primary&#34;]
.Groovy
----
docker {
    registryCredentials {
        url = &#39;https://gcr.io&#39;
        username = &#39;_json_key&#39;
        password = file(&#39;keyfile.json&#39;).text
    }
}
----

[source,kotlin,indent=0,subs=&#34;verbatim,attributes&#34;,role=&#34;secondary&#34;]
.Kotlin
----
docker {
    registryCredentials {
        url.set(&#34;https://gcr.io&#34;)
        username.set(&#34;_json_key&#34;)
        password.set(file(&#34;keyfile.json&#34;).readText())
    }
}
----</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Listing 8. A tabbed code block for rendering Groovy and Kotlin source code side-by-side</em></p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_summary">Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>AsciidoctorJ provides an extension mechanism for enhancing Asciidoctor’s built-in capabilities. In this post, we experienced how to create a customizable tabbed code block by implementing an extension point that modifies the header of a generated HTML document. We learned the essentials about implementing an appropriate extension point and writing tests for it. Later, we briefly touched on the tooling support for bundling and publishing an extension.</p>
</div>
</div>
</div>

              <hr>
              <div class="related-posts">
                <h5>Related Posts</h5>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        November 12, 2018
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/java-project-testcontainers/">Testing a Java project with TestContainers on JUnit 5</a></strong>
                      </h6>
                    </div>
                  </div>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        June 13, 2018
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/go-testing-frameworks/">Exploring the landscape of Go testing frameworks</a></strong>
                      </h6>
                    </div>
                  </div>
                
                  <div class="row">
                    <div class="col-sm-4 col-md-4 col-lg-4">
                      <h6 style="text-align: right">
                        February 18, 2018
                      </h6>
                    </div>
                    <div class="col-sm-8 col-md-8 col-lg-8">
                      <h6 style="text-align: left">
                        <strong><a href="/blog/docker-integration-testing/">Docker with Gradle: Integration testing using containers</a></strong>
                      </h6>
                    </div>
                  </div>
                
              </div>
            </div>
          </div>
          <hr>
        <div class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">

    (function() {
      
      
      if (window.location.hostname == "localhost")
        return;

      var disqus_shortname = 'bmuschko-com';
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
        </div>
      </div>
    </div>

    
    <footer>
  <div id="footer">
    <div class="container">
      <p class="text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io/">Hugo</a> and
      <a href="http://www.github.com/nurlansu/hugo-sustain/">sustain</a> with ♥</p>
    </div>
  </div>
</footer>
<div class="footer"></div>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://bmuschko.com/js/docs.min.js"></script>
<script src="https://bmuschko.com/js/main.js"></script>

<script src="https://bmuschko.com/js/ie10-viewport-bug-workaround.js"></script><!-- Syntax highlighting -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/shell.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/groovy.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



    
  </body>
</html>
